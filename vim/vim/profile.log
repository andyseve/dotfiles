FUNCTION  airline#extensions#quickfix#inactive_qf_window()
Called 28 times
Total time:   0.000502
 Self time:   0.000422

count  total (s)   self (s)
   28   0.000343   0.000263   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
   23              0.000077     call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
   23              0.000014   endif

FUNCTION  <SNR>91_CheckDefined()
Called 3437 times
Total time:   0.033425
 Self time:   0.033425

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
 3437              0.007588   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
 3437              0.006940   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
 3437              0.003390     return a:colors
                              endif
                            
                              for val in a:colors
                                if !empty(val) && val !=# 'NONE'
                                  return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  <SNR>86_get_wordcount()
Called 1 time
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    1              0.000001     let query = a:visual_mode_active ? 'visual_words' : 'words'
    1              0.000065     return get(wordcount(), query, 0)

FUNCTION  <SNR>95_get_section()
Called 394 times
Total time:   0.010176
 Self time:   0.009163

count  total (s)   self (s)
  394              0.000782   if has_key(s:section_truncate_width, a:key)
  256              0.000564     if winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
                                endif
  256              0.000127   endif
  394              0.000551   let spc = g:airline_symbols.space
  394              0.001141   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
  394   0.002805   0.001792   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
  394              0.001686   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
  394              0.001016   return empty(text) ? '' : prefix.text.suffix

FUNCTION  <SNR>163_GetAliasedFiletype()
Called 1 time
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
    1              0.000019     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List.
    1              0.000014     if type(l:buffer_aliases) is v:t_list
                                    return l:buffer_aliases
                                endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
    4              0.000024     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
    3              0.000023         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
    3              0.000006     endfor
                            
    1              0.000005     return a:original_filetype

FUNCTION  <SNR>101_buffer_type()
Called 11 times
Total time:   0.001262
 Self time:   0.000627

count  total (s)   self (s)
   11   0.000039   0.000021   if !empty(self.getvar('fugitive_type'))
                                let type = self.getvar('fugitive_type')
                              elseif fnamemodify(self.spec(),':p') =~# '\.git/refs/\|\.git/\w*HEAD$'
                                let type = 'head'
                              elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
                                let type = 'index'
                              elseif isdirectory(self.spec())
                                let type = 'directory'
                              elseif self.spec() == ''
                                let type = 'null'
                              else
   11              0.000005     let type = 'file'
   11              0.000004   endif
   11              0.000005   if a:0
   11              0.000037     return !empty(filter(copy(a:000),'v:val ==# type'))
                              else
                                return type
                              endif

FUNCTION  airline#util#exec_funcrefs()
Called 55 times
Total time:   0.031384
 Self time:   0.002667

count  total (s)   self (s)
  255              0.000311     for Fn in a:list
  246   0.029732   0.001015       let code = call(Fn, a:000)
  246              0.000196       if code != 0
   46              0.000050         return code
                                  endif
  200              0.000730     endfor
    9              0.000007     return 0

FUNCTION  ale#linter#Get()
Called 1 time
Total time:   0.001057
 Self time:   0.000606

count  total (s)   self (s)
    1              0.000007     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
    2              0.000030     for l:original_filetype in split(a:original_filetypes, '\.')
    1   0.000282   0.000069         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
    1   0.000144   0.000049         let l:linter_names = s:GetLinterNames(l:original_filetype)
    1   0.000170   0.000027         let l:all_linters = ale#linter#GetAll(l:filetype)
    1              0.000005         let l:filetype_linters = []
                            
    1              0.000012         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
    1              0.000007             let l:filetype_linters = l:all_linters
    1              0.000006         elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
                                    endif
                            
    1              0.000011         call extend(l:possibly_duplicated_linters, l:filetype_linters)
    1              0.000002     endfor
                            
    1              0.000005     let l:name_list = []
    1              0.000005     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
    8              0.000028     for l:linter in reverse(l:possibly_duplicated_linters)
    7              0.000046         if index(l:name_list, l:linter.name) < 0
    7              0.000043             call add(l:name_list, l:linter.name)
    7              0.000065             call add(l:combined_linters, l:linter)
    7              0.000014         endif
    7              0.000009     endfor
                            
    1              0.000007     return reverse(l:combined_linters)

FUNCTION  <SNR>94_get_accented_line()
Called 294 times
Total time:   0.009830
 Self time:   0.009830

count  total (s)   self (s)
  294              0.000356   if a:self._context.active
  126              0.000101     let contents = []
  126              0.000562     let content_parts = split(a:contents, '__accent')
  306              0.000279     for cpart in content_parts
  180              0.000824       let accent = matchstr(cpart, '_\zs[^#]*\ze')
  180              0.000271       call add(contents, cpart)
  180              0.000104     endfor
  126              0.000209     let line = join(contents, a:group)
  126              0.000470     let line = substitute(line, '__restore__', a:group, 'g')
  126              0.000058   else
  168              0.002454     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
  168              0.000908     let line = substitute(line, '%#__restore__#', '', 'g')
  168              0.000118   endif
  294              0.000234   return line

FUNCTION  441()
Called 864 times
Total time:   0.010285
 Self time:   0.010285

count  total (s)   self (s)
  864              0.005113   silent! call matchdelete(w:vimtex_match_id1)
  864              0.002950   silent! call matchdelete(w:vimtex_match_id2)
  864              0.001181   unlet! w:vimtex_match_id1
  864              0.000596   unlet! w:vimtex_match_id2

FUNCTION  airline#extensions#term#apply()
Called 18 times
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
   18              0.000014   if &buftype == 'terminal'
                                let spc = g:airline_symbols.space
                            
                                let name=get(g:airline_mode_map, 't', 't')
                                call a:1.add_section('airline_a', spc.name.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_term', spc.'%f')
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
                              endif

FUNCTION  airline#statusline()
Called 2200 times
Total time:   0.025834
 Self time:   0.025834

count  total (s)   self (s)
 2200              0.012421   if has_key(s:contexts, a:winnr)
 2200              0.010709     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#check_mode()
Called 2200 times
Total time:   0.452758
 Self time:   0.149339

count  total (s)   self (s)
 2200              0.004921   let context = s:contexts[a:winnr]
                            
 2200              0.004849   if get(w:, 'airline_active', 1)
 2168              0.003833     let l:m = mode(1)
 2168              0.002209     if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "Rv"
                                  let l:mode =['replace']
                                elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                elseif l:m[0] ==# "c"
                                  let l:mode = ['commandline']
                                elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
                                elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
                                else
 2168              0.003360       let l:mode = ['normal']
 2168              0.001015     endif
 2168              0.006012     if index(['Rv', 'no', 'ni', 'ix', 'ic'], l:m) == -1
 2168              0.002713       let l:m = l:m[0]
 2168              0.000945     endif
 2168              0.005755     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
 2168              0.000931   else
   32              0.000052     let l:mode = ['inactive']
   32              0.000097     let w:airline_current_mode = get(g:airline_mode_map, '__')
   32              0.000022   endif
                            
 2200              0.003826   if g:airline_detect_modified && &modified
 2175              0.004891     call add(l:mode, 'modified')
 2175              0.000940   endif
                            
 2200              0.002265   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
 2200              0.005520   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
 2200              0.002223   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
 2200              0.001854   if &readonly || ! &modifiable
   22              0.000061     call add(l:mode, 'readonly')
   22              0.000009   endif
                            
 2200              0.008861   let mode_string = join(l:mode)
 2200              0.004260   if get(w:, 'airline_lastmode', '') != mode_string
   15   0.002627   0.000060     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   15   0.300507   0.000073     call airline#highlighter#highlight(l:mode, context.bufnr)
   15   0.000485   0.000067     call airline#util#doautocmd('AirlineModeChanged')
   15              0.000023     let w:airline_lastmode = mode_string
   15              0.000006   endif
                            
 2200              0.001581   return ''

FUNCTION  <SNR>131_parser_latex()
Called 50 times
Total time:   0.001547
 Self time:   0.001547

count  total (s)   self (s)
   50              0.000064   let result = {}
                            
   50              0.000055   let result.type = 'env'
   50              0.000160   let result.side = a:match =~# '\\(\|\\\[' ? 'open' : 'close'
   50              0.000064   let result.is_open = result.side ==# 'open'
   50              0.000166   let result.get_matching = function('s:get_matching_latex')
                            
   50              0.000340   let result.corr = result.is_open ? substitute(substitute(a:match, '\[', ']', ''), '(', ')', '') : substitute(substitute(a:match, '\]', '[', ''), ')', '(', '')
                            
   50              0.000386   let result.re = { 'open'  : a:match =~# '\\(\|\\)' ? '\m\\(' : '\m\\\[', 'close' : a:match =~# '\\(\|\\)' ? '\m\\)' : '\m\\\]',}
                            
   50              0.000092   let result.re.this = result.is_open ? result.re.open  : result.re.close
   50              0.000066   let result.re.corr = result.is_open ? result.re.close : result.re.open
                            
   50              0.000038   return result

FUNCTION  airline#util#append()
Called 15246 times
Total time:   0.083372
 Self time:   0.083372

count  total (s)   self (s)
15246              0.017428   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
15246              0.025146   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
15246              0.023958   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  airline#extensions#vimtex#apply()
Called 18 times
Total time:   0.000134
 Self time:   0.000134

count  total (s)   self (s)
   18              0.000026   if exists("b:vimtex")
   18              0.000044     let w:airline_section_x = get(w:, 'airline_section_x', g:airline_section_x)
   18              0.000046     let w:airline_section_x.=s:spc.g:airline_left_alt_sep.s:spc.'%{airline#extensions#vimtex#get_scope()}'
   18              0.000002   endif

FUNCTION  <SNR>56_airline_refresh()
Called 9 times
Total time:   0.581527
 Self time:   0.000959

count  total (s)   self (s)
    9              0.000103   if !exists("#airline")
                                " disabled
                                return
                              endif
    9   0.000872   0.000141   call airline#util#doautocmd('AirlineBeforeRefresh')
    9   0.001021   0.000153   call airline#highlighter#reset_hlcache()
    9   0.482593   0.000448   call airline#load_theme()
    9   0.096864   0.000040   call airline#update_statusline()

FUNCTION  <SNR>101_buffer_getline()
Called 33 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
   33              0.000078   return get(getbufline(self['#'], a:lnum), 0, '')

FUNCTION  airline#themes#get_highlight()
Called 2560 times
Total time:   0.225119
 Self time:   0.010213

count  total (s)   self (s)
 2560   0.224680   0.009774   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  vimtex#matchparen#popup_check()
Called 3759 times
Total time:   0.123581
 Self time:   0.123581

count  total (s)   self (s)
 3759              0.067572   if pumvisible()
                                call s:matchparen.highlight()
                              endif

FUNCTION  ale#linter#ResolveFiletype()
Called 1 time
Total time:   0.000213
 Self time:   0.000071

count  total (s)   self (s)
    1   0.000199   0.000057     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
    1              0.000007     if type(l:filetype) isnot v:t_list
    1              0.000005         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  <SNR>128_get_cmd()
Called 158 times
Total time:   0.238223
 Self time:   0.010511

count  total (s)   self (s)
  158   0.003644   0.000695   let [lnum, cnum, match] = s:get_cmd_name(a:direction ==# 'next')
  158              0.000336   if lnum == 0 | return {} | endif
                            
  158              0.000975   let res = { 'name' : match, 'pos_start' : { 'lnum' : lnum, 'cnum' : cnum }, 'pos_end' : { 'lnum' : lnum, 'cnum' : cnum + strlen(match) - 1 }, 'args' : [],}
                            
                              " Environments always start with environment name and allows option
                              " afterwords
  158              0.000168   if res.name ==# '\begin'
  158   0.090491   0.000653     let arg = s:get_cmd_part('{', res.pos_end)
  158              0.000331     call add(res.args, arg)
  158              0.000215     let res.pos_end.lnum = arg.close.lnum
  158              0.000143     let res.pos_end.cnum = arg.close.cnum
  158              0.000064   endif
                            
                              " Get overlay specification
  158   0.002524   0.000710   let res.overlay = s:get_cmd_overlay(res.pos_end.lnum, res.pos_end.cnum)
  158              0.000189   if !empty(res.overlay)
                                let res.pos_end.lnum = res.overlay.close.lnum
                                let res.pos_end.cnum = res.overlay.close.cnum
                              endif
                            
                              " Get options
  158   0.066075   0.001709   let res.opt = s:get_cmd_part('[', res.pos_end)
  158              0.000191   if !empty(res.opt)
   33              0.000050     let res.pos_end.lnum = res.opt.close.lnum
   33              0.000037     let res.pos_end.cnum = res.opt.close.cnum
   33              0.000013   endif
                            
                              " Get arguments
  158   0.067078   0.000762   let arg = s:get_cmd_part('{', res.pos_end)
  158              0.000235   while !empty(arg)
                                call add(res.args, arg)
                                let res.pos_end.lnum = arg.close.lnum
                                let res.pos_end.cnum = arg.close.cnum
                                let arg = s:get_cmd_part('{', res.pos_end)
                              endwhile
                            
                              " Include entire cmd text
  158   0.003150   0.000721   let res.text = s:text_between(res.pos_start, res.pos_end, 1)
                            
  158              0.000102   return res

FUNCTION  vimtex#util#in_syntax()
Called 888 times
Total time:   1.206097
 Self time:   1.206097

count  total (s)   self (s)
                            
                              " Usage: vimtex#util#in_syntax(name, [line, col])
                            
                              " Get position and correct it if necessary
  888              0.003445   let l:pos = a:0 > 0 ? [a:1, a:2] : [line('.'), col('.')]
  888              0.001064   if mode() ==# 'i'
                                let l:pos[1] -= 1
                              endif
  888              0.003870   call map(l:pos, 'max([v:val, 1])')
                            
                              " Check syntax at position
  888              1.194072   return match(map(synstack(l:pos[0], l:pos[1]),          "synIDattr(v:val, 'name')"),      '^' . a:name) >= 0

FUNCTION  airline#extensions#vimtex#get_scope()
Called 2178 times
Total time:   0.089820
 Self time:   0.076789

count  total (s)   self (s)
 2178              0.002533   let l:status = ''
                            
 2178              0.004707   let vt_local = get(b:, 'vimtex_local', {})
 2178              0.002333   if empty(vt_local)
 2178              0.004185     let l:status .= g:airline#extensions#vimtex#main
 2178              0.001006   else
                                if get(vt_local, 'active')
                                  let l:status .= g:airline#extensions#vimtex#sub_local
                                else
                                  let l:status .= g:airline#extensions#vimtex#sub_main
                                endif
                              endif
                            
 2178              0.006007   if get(get(get(b:, 'vimtex', {}), 'viewer', {}), 'xwin_id')
 2178              0.003187     let l:status .= g:airline#extensions#vimtex#viewer
 2178              0.000912   endif
                            
 2178              0.004725   let l:compiler = get(get(b:, 'vimtex', {}), 'compiler', {})
 2178              0.002633   if !empty(l:compiler)
 2178   0.021740   0.008709     if has_key(l:compiler, 'is_running') && b:vimtex.compiler.is_running()
 2178              0.002967       if get(l:compiler, 'continuous')
 2178              0.003487         let l:status .= g:airline#extensions#vimtex#continuous
 2178              0.000941       else
                                    let l:status .= g:airline#extensions#vimtex#compiled
                                  endif
 2178              0.000763     endif
 2178              0.000743   endif
                            
 2178              0.002383   if !empty(l:status)
 2178              0.005068     let l:status = g:airline#extensions#vimtex#left . l:status . g:airline#extensions#vimtex#right
 2178              0.000791   endif
 2178              0.001611   return l:status

FUNCTION  airline#extensions#fugitiveline#bufname()
Called 2178 times
Total time:   0.045372
 Self time:   0.043964

count  total (s)   self (s)
 2178              0.004153   if !exists('b:fugitive_name')
   11              0.000010     let b:fugitive_name = ''
   11              0.000006     try
   11              0.000043       if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
                                  elseif exists('b:git_dir')
   11   0.000172   0.000026         let buffer = fugitive#buffer()
   11   0.001290   0.000028         if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
   11              0.000003       endif
   11              0.000008     catch
                                endtry
   11              0.000003   endif
                            
 2178              0.002544   if empty(b:fugitive_name)
 2178              0.012265     return fnamemodify(bufname('%'), s:fmod)
                              else
                                return fnamemodify(b:fugitive_name, s:fmod)
                              endif

FUNCTION  ale#statusline#Count()
Called 2204 times
Total time:   0.036829
 Self time:   0.010381

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
 2204   0.035668   0.009220     return copy(s:GetCounts(a:buffer))

FUNCTION  <SNR>185_FindItemAtCursor()
Called 85 times
Total time:   0.008438
 Self time:   0.002461

count  total (s)   self (s)
   85              0.000483     let l:info = get(g:ale_buffer_info, a:buffer, {})
   85              0.000297     let l:loclist = get(l:info, 'loclist', [])
   85              0.000250     let l:pos = getcurpos()
   85   0.006746   0.000769     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
   85              0.000295     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
   85              0.000199     return [l:info, l:loc]

FUNCTION  <SNR>91_exec_separator()
Called 1280 times
Total time:   0.429678
 Self time:   0.031760

count  total (s)   self (s)
 1280              0.001716   if pumvisible()
                                return
                              endif
 1280   0.118097   0.004607   let l:from = airline#themes#get_highlight(a:from.a:suffix)
 1280   0.116033   0.004404   let l:to = airline#themes#get_highlight(a:to.a:suffix)
 1280              0.002641   let group = a:from.'_to_'.a:to.a:suffix
 1280              0.000997   if a:inverse
  520              0.001817     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  520              0.000264   else
  760              0.002582     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  760              0.000352   endif
 1280              0.002309   let a:dict[group] = colors
 1280   0.177704   0.004905   call airline#highlighter#exec(group, colors)

FUNCTION  airline#util#has_fugitive()
Called 2196 times
Total time:   0.005966
 Self time:   0.005966

count  total (s)   self (s)
 2196              0.005433   return exists('*fugitive#head') || exists('*FugitiveHead')

FUNCTION  fugitive#buffer()
Called 20 times
Total time:   0.000282
 Self time:   0.000235

count  total (s)   self (s)
   20              0.000057   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
   20              0.000099   call extend(buffer, s:buffer_prototype, 'keep')
   20   0.000103   0.000056   if buffer.getvar('git_dir') !=# ''
   20              0.000013     return buffer
                              endif
                              call s:throw('not a git repository: '.bufname(buffer['#']))

FUNCTION  <SNR>94_section_is_empty()
Called 358 times
Total time:   0.018345
 Self time:   0.008224

count  total (s)   self (s)
  358              0.000362   let start=1
                            
                              " do not check for inactive windows or the tabline
  358              0.000436   if a:self._context.active == 0
  196              0.000176     return 0
                              elseif get(a:self._context, 'tabline', 0)
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
  162              0.000225   if get(g:, 'airline_skip_empty_sections', 0) == 0
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
  162              0.000202   if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
  162              0.002080   if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
   54              0.000038     return 0
                              endif
  108              0.000099   if empty(a:content)
                                return 1
                              endif
  108              0.000922   let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
  108              0.000105   if empty(list)
   18              0.000009     return 0 " no function in statusline text
                              endif
  144              0.000155   while len(list) > 0
  126              0.000160     let expr = list[0]
  126              0.000059     try
                                  " catch all exceptions, just in case
  126   0.010698   0.000577       if !empty(eval(expr))
   72              0.000055         return 0
                                  endif
   54              0.000028     catch
                                  return 0
                                endtry
   54              0.000061     let start += 1
   54              0.000589     let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
   54              0.000043   endw
   18              0.000013   return 1

FUNCTION  airline#parts#filetype()
Called 2196 times
Total time:   0.007586
 Self time:   0.007586

count  total (s)   self (s)
 2196              0.007107   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 18 times
Total time:   0.000231
 Self time:   0.000231

count  total (s)   self (s)
   18              0.000054   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  <SNR>97_OnFileReadyToParse()
Called 1 time
Total time:   0.002167
 Self time:   0.002057

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
    1              0.000004   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
    1   0.000120   0.000010   if force_parsing || s:Pyeval( "ycm_state.NeedsReparse()" )
    1              0.002012     exec s:python_command "ycm_state.OnFileReadyToParse()"
                            
    1              0.000009     call timer_stop( s:pollers.file_parse_response.id )
    1              0.000016     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
    1              0.000002   endif

FUNCTION  airline#parts#iminsert()
Called 2178 times
Total time:   0.007732
 Self time:   0.007732

count  total (s)   self (s)
 2178              0.003018   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
 2178              0.001034   return ''

FUNCTION  <SNR>97_Pyeval()
Called 3 times
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
    3              0.000004   if s:using_python3
    3              0.000193     return py3eval( a:eval_string )
                              endif
                              return pyeval( a:eval_string )

FUNCTION  <SNR>95_add_section()
Called 312 times
Total time:   0.016004
 Self time:   0.006169

count  total (s)   self (s)
  312              0.001017     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
  312   0.001622   0.001003     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
  312              0.000229     if condition
                                  call a:builder.add_raw('%(')
                                endif
  312   0.011150   0.001934     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
  312              0.000246     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  <SNR>131_parser_delim_get_corr()
Called 577 times
Total time:   0.024902
 Self time:   0.024902

count  total (s)   self (s)
  577              0.000758   let l:type = a:0 > 0 ? a:1 : 'delim_all'
                            
 5258              0.003380   for l:pair in g:vimtex#delim#lists[l:type].name
 5258              0.005247     if a:delim ==# l:pair[0]
  507              0.000462       return l:pair[1]
                                elseif a:delim ==# l:pair[1]
   70              0.000060       return l:pair[0]
                                endif
 4681              0.001920   endfor

FUNCTION  airline#extensions#apply()
Called 46 times
Total time:   0.003720
 Self time:   0.001742

count  total (s)   self (s)
                            
   46   0.002175   0.000197   if s:is_excluded_window()
                                return -1
                              endif
                            
   46              0.000074   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
   46              0.000045   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
   46              0.000252   if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
   46              0.000136   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  ale#ShouldDoNothing()
Called 85 times
Total time:   0.009713
 Self time:   0.006990

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
   85              0.000514     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
                                endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
   85              0.000306     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
   85              0.000364     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
   85              0.000137     if l:filetype is# ''
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files.
   85              0.000442     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode.
   85              0.000383     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
   85              0.000440     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
   85              0.000125     if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Don't start linting and so on when an operator is pending.
   85   0.000863   0.000460     if ale#util#Mode(1) is# 'no'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox.
   85   0.001684   0.000368     if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
   85   0.001458   0.000454     if ale#FileTooLarge(a:buffer)
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
   85              0.000646     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
   85              0.000090     return 0

FUNCTION  <SNR>82_update_branch()
Called 2196 times
Total time:   0.525037
 Self time:   0.067625

count  total (s)   self (s)
 6588              0.009987   for vcs in keys(s:vcs_config)
 4392   0.478501   0.021089     call {s:vcs_config[vcs].update_branch}()
 4392              0.009439     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
                                endif
 4392              0.003267   endfor

FUNCTION  airline#extensions#ale#get_error()
Called 18 times
Total time:   0.000817
 Self time:   0.000057

count  total (s)   self (s)
   18   0.000812   0.000052   return airline#extensions#ale#get('error')

FUNCTION  airline#extensions#po#apply()
Called 18 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
   18              0.000034   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                              endif

FUNCTION  327()
Called 2178 times
Total time:   0.013031
 Self time:   0.013031

count  total (s)   self (s)
 2178              0.012309   return has_key(self, 'job') && job_status(self.job) ==# 'run'

FUNCTION  <SNR>91_Get()
Called 1512 times
Total time:   0.005791
 Self time:   0.005791

count  total (s)   self (s)
 1512              0.002302   let res=get(a:dict, a:key, '')
 1512              0.000934   if res is ''
  471              0.000226     return ''
                              else
 1041              0.001062     return a:prefix. res
                              endif

FUNCTION  <SNR>131_parser_delim_get_regexp()
Called 1154 times
Total time:   0.021995
 Self time:   0.021995

count  total (s)   self (s)
 1154              0.001723   let l:type = a:0 > 0 ? a:1 : 'delim_all'
                            
                              " First check for unmatched math delimiter
 1154              0.000925   if a:delim ==# '.'
                                return g:vimtex#delim#re.delim_math[a:side ? 'open' : 'close']
                              endif
                            
                              " Next check normal delimiters
 1154              0.012717   let l:index = index(map(copy(g:vimtex#delim#lists[l:type].name),   'v:val[' . a:side . ']'), a:delim)
 1154              0.003076   return l:index >= 0 ? g:vimtex#delim#lists[l:type].re[l:index][a:side] : ''

FUNCTION  airline#util#doautocmd()
Called 24 times
Total time:   0.001149
 Self time:   0.000534

count  total (s)   self (s)
   24   0.001135   0.000520   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  ale#cursor#EchoCursorWarning()
Called 86 times
Total time:   0.024264
 Self time:   0.006113

count  total (s)   self (s)
   86              0.000684     let l:buffer = bufnr('')
                            
   86              0.000256     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
   86              0.000274     if mode(1) isnot# 'n'
    1              0.000001         return
                                endif
                            
   85   0.010190   0.000477     if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
   85   0.009177   0.000739     let [l:info, l:loc] = s:FindItemAtCursor(l:buffer)
                            
   85              0.000122     if g:ale_echo_cursor
   85              0.000200         if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
                                    elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        execute 'echo'
                                        let l:info.echoed = 0
                                    endif
   85              0.000066     endif
                            
   85              0.000123     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
                                endif

FUNCTION  AbsoluteNumber()
Called 5 times
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
    5              0.000095       set norelativenumber
    5              0.000031       set number

FUNCTION  vimtex#delim#get_matching()
Called 519 times
Total time:   0.244491
 Self time:   0.030700

count  total (s)   self (s)
  519              0.001675   if empty(a:delim) || !has_key(a:delim, 'lnum') | return {} | endif
                            
                              "
                              " Get the matching position
                              "
  519   0.002930   0.001246   let l:save_pos = vimtex#pos#get_cursor()
  519   0.009747   0.002440   call vimtex#pos#set_cursor(a:delim)
  519   0.026078   0.002404   let [l:match, l:lnum, l:cnum] = a:delim.get_matching()
  519   0.010310   0.001595   call vimtex#pos#set_cursor(l:save_pos)
                            
                              "
                              " Create the match result
                              "
  519              0.002613   let l:matching = deepcopy(a:delim)
  519              0.000674   let l:matching.lnum = l:lnum
  519              0.000452   let l:matching.cnum = l:cnum
  519              0.000567   let l:matching.match = l:match
  519              0.000591   let l:matching.corr  = a:delim.match
  519              0.000678   let l:matching.side = a:delim.is_open ? 'close' : 'open'
  519              0.000575   let l:matching.is_open = !a:delim.is_open
  519              0.000615   let l:matching.re.corr = a:delim.re.this
  519              0.000499   let l:matching.re.this = a:delim.re.corr
                            
  519              0.000537   if l:matching.type ==# 'delim'
  287              0.000307     let l:matching.corr_delim = a:delim.delim
  287              0.000288     let l:matching.corr_mod = a:delim.mod
  287              0.000281     let l:matching.delim = a:delim.corr_delim
  287              0.000280     let l:matching.mod = a:delim.corr_mod
  287              0.000445   elseif l:matching.type ==# 'env' && has_key(l:matching, 'name')
  158              0.000113     if l:matching.is_open
   99              0.058543       let l:matching.env_cmd = vimtex#cmd#get_at(l:lnum, l:cnum)
   99              0.000041     else
   59              0.000167       unlet l:matching.env_cmd
   59              0.000021     endif
  158              0.000071   endif
                            
  519              0.000450   return l:matching

FUNCTION  vimtex#pos#set_cursor()
Called 3795 times
Total time:   0.066767
 Self time:   0.014295

count  total (s)   self (s)
 3795   0.065817   0.013345   call cursor(s:parse_args(a:000))

FUNCTION  airline#extensions#default#apply()
Called 46 times
Total time:   0.023130
 Self time:   0.001871

count  total (s)   self (s)
   46              0.000103   let winnr = a:context.winnr
   46              0.000075   let active = a:context.active
                            
   46   0.000402   0.000247   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
   46   0.009714   0.000290     call s:build_sections(a:builder, a:context, s:layout[0])
   46              0.000028   else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
                              endif
                            
   46   0.001758   0.000311   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   46   0.000255   0.000147   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
   46   0.010343   0.000218     call s:build_sections(a:builder, a:context, s:layout[1])
   46              0.000023   endif
                            
   46              0.000038   return 1

FUNCTION  ale#FileTooLarge()
Called 85 times
Total time:   0.001004
 Self time:   0.001004

count  total (s)   self (s)
   85              0.000536     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
   85              0.000367     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  <SNR>97_OnTextChangedNormalMode()
Called 1 time
Total time:   0.002259
 Self time:   0.000025

count  total (s)   self (s)
    1   0.000074   0.000007   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    1   0.002181   0.000014   call s:OnFileReadyToParse()

FUNCTION  <SNR>131_parser_delim()
Called 570 times
Total time:   0.089106
 Self time:   0.042209

count  total (s)   self (s)
  570              0.000707   let result = {}
  570              0.000736   let result.type = 'delim'
  570              0.008758   let result.side = a:match =~# g:vimtex#delim#re.delim_all.open ? 'open' : 'close'
  570              0.000909   let result.is_open = result.side ==# 'open'
  570              0.002064   let result.get_matching = function('s:get_matching_delim')
                            
                              "
                              " Find corresponding delimiter and the regexps
                              "
  570              0.005494   if a:match =~# '^' . g:vimtex#delim#re.mods.both
    7              0.000054     let m1 = matchstr(a:match, '^' . g:vimtex#delim#re.mods.both)
    7              0.000036     let d1 = substitute(strpart(a:match, len(m1)), '^\s*', '', '')
    7              0.000006     let s1 = !result.is_open
    7   0.000277   0.000047     let re1 = s:parser_delim_get_regexp(m1, s1, 'mods')  . '\s*' . s:parser_delim_get_regexp(d1, s1, 'delim_math')
                            
    7   0.000064   0.000017     let m2 = s:parser_delim_get_corr(m1, 'mods')
    7   0.000053   0.000015     let d2 = s:parser_delim_get_corr(d1, 'delim_math')
    7              0.000004     let s2 = result.is_open
    7   0.000243   0.000077     let re2 = s:parser_delim_get_regexp(m2, s2, 'mods') . '\s*' . (m1 =~# '\\\%(left\|right\)'   ? '\%(' . s:parser_delim_get_regexp(d2, s2, 'delim_math') . '\|\.\)'   : s:parser_delim_get_regexp(d2, s2, 'delim_math'))
    7              0.000004   else
  563              0.000607     let d1 = a:match
  563              0.000442     let m1 = ''
  563   0.014137   0.002194     let re1 = s:parser_delim_get_regexp(a:match, !result.is_open)
                            
  563   0.026721   0.001904     let d2 = s:parser_delim_get_corr(a:match)
  563              0.000461     let m2 = ''
  563   0.011542   0.001886     let re2 = s:parser_delim_get_regexp(d2, result.is_open)
  563              0.000289   endif
                            
  570              0.000653   let result.delim = d1
  570              0.000502   let result.mod = m1
  570              0.000749   let result.corr = m2 . d2
  570              0.000488   let result.corr_delim = d2
  570              0.000513   let result.corr_mod = m2
  570              0.002240   let result.re = { 'this'  : re1, 'corr'  : re2, 'open'  : result.is_open ? re1 : re2, 'close' : result.is_open ? re2 : re1,}
                            
  570              0.000415   return result

FUNCTION  <SNR>97_AllowedToCompleteInCurrentBuffer()
Called 865 times
Total time:   0.028245
 Self time:   0.002932

count  total (s)   self (s)
  865   0.028026   0.002713   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  airline#util#wrap()
Called 13170 times
Total time:   0.042778
 Self time:   0.042778

count  total (s)   self (s)
13170              0.018756   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
13170              0.009176   return a:text

FUNCTION  airline#extensions#ale#get()
Called 2204 times
Total time:   0.163641
 Self time:   0.063369

count  total (s)   self (s)
 2204              0.005666   if !exists(':ALELint')
                                return ''
                              endif
                            
 2204              0.003090   let is_err = a:type ==# 'error'
 2204              0.003741   let symbol = is_err ? s:error_symbol : s:warning_symbol
                            
 2204              0.002246   let is_err = a:type ==# 'error'
 2204   0.043735   0.006906   let counts = ale#statusline#Count(bufnr(''))
 2204              0.003200   let symbol = is_err ? s:error_symbol : s:warning_symbol
                            
 2204              0.005447   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
 2204              0.003455     let errors = counts.error + counts.style_error
 2204              0.003472     let num = is_err ? errors : counts.total - errors
 2204              0.000995   else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
                              endif
                            
 2204              0.002153   if s:show_line_numbers == 1
 2204   0.075907   0.012464     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif

FUNCTION  FugitiveGitDir()
Called 2196 times
Total time:   0.007408
 Self time:   0.007408

count  total (s)   self (s)
 2196              0.002191   if !a:0 || a:1 ==# -1
 2196              0.004263     return get(b:, 'git_dir', '')
                              elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
                              elseif type(a:1) == type('')
                                return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  <SNR>97_OnCursorMovedNormalMode()
Called 864 times
Total time:   0.083932
 Self time:   0.055754

count  total (s)   self (s)
  864   0.030776   0.002598   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
  864              0.051773   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  airline#util#getwinvar()
Called 578 times
Total time:   0.001615
 Self time:   0.001615

count  total (s)   self (s)
  578              0.001496     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  <SNR>163_GetLinterNames()
Called 1 time
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
    1              0.000012     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
    1              0.000005     if l:buffer_ale_linters is# 'all'
                                    return 'all'
                                endif
                            
                                " b:ale_linters can be set to a List.
    1              0.000007     if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
                                endif
                            
                                " Try to get a buffer-local setting for the filetype
    1              0.000007     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
                                endif
                            
                                " Try to get a global setting for the filetype
    1              0.000006     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
                                endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
    1              0.000004     if g:ale_linters_explicit
                                    return []
                                endif
                            
                                " Try to get a default setting for the filetype
    1              0.000006     if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
                                endif
                            
    1              0.000003     return 'all'

FUNCTION  ale#hover#Show()
Called 1 time
Total time:   0.001230
 Self time:   0.000173

count  total (s)   self (s)
    8   0.001113   0.000056     for l:linter in ale#linter#Get(getbufvar(a:buffer, '&filetype'))
    7              0.000028         if !empty(l:linter.lsp)
                                        call s:ShowDetails(l:linter, a:buffer, a:line, a:col, a:opt)
                                    endif
    7              0.000010     endfor

FUNCTION  <SNR>97_AllowedToCompleteInBuffer()
Called 865 times
Total time:   0.025313
 Self time:   0.022117

count  total (s)   self (s)
  865              0.002936   let buffer_filetype = getbufvar( a:buffer, '&filetype' )
                            
  865              0.003133   if empty( buffer_filetype ) || getbufvar( a:buffer, '&buftype' ) ==# 'nofile' || buffer_filetype ==# 'qf'
                                return 0
                              endif
                            
  865   0.005586   0.002390   if s:DisableOnLargeFile( a:buffer )
                                return 0
                              endif
                            
  865              0.003110   let whitelist_allows = has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, buffer_filetype )
  865              0.002103   let blacklist_allows = !has_key( g:ycm_filetype_blacklist, buffer_filetype )
                            
  865              0.001195   let allowed = whitelist_allows && blacklist_allows
  865              0.000572   if allowed
  865              0.002000     let s:previous_allowed_buffer_number = bufnr( a:buffer )
  865              0.000384   endif
  865              0.000654   return allowed

FUNCTION  <SNR>91_get_array()
Called 6401 times
Total time:   0.037587
 Self time:   0.037587

count  total (s)   self (s)
 6401              0.015676   let opts=empty(a:opts) ? '' : join(a:opts, ',')
 6401              0.020095   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  <SNR>94_get_transitioned_seperator()
Called 248 times
Total time:   0.187394
 Self time:   0.006787

count  total (s)   self (s)
  248              0.000216   let line = ''
  248   0.091947   0.001007   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
  248              0.000844   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
                              else
  248   0.090814   0.001147     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
  248              0.000719     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
  248              0.000686     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
  248              0.000345     let line .= '%#'.a:group.'#'
  248              0.000104   endif
  248              0.000202   return line

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 24 times
Total time:   0.007028
 Self time:   0.000843

count  total (s)   self (s)
   24              0.000116   if getbufvar(a:bufnr, '&modified')
   14              0.000080     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
   14              0.000007   else
   10              0.000170     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
   10              0.000014   endif
                            
   24              0.000055   if !empty(colors)
   24   0.006406   0.000221     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   24              0.000018   endif

FUNCTION  <SNR>40_CursorHoldUpdate()
Called 4 times
Total time:   0.002733
 Self time:   0.000178

count  total (s)   self (s)
    4              0.000043     if g:NERDTreeUpdateOnCursorHold != 1
                                    return
                                endif
                            
    4   0.002614   0.000059     if !g:NERDTree.IsOpen()
    4              0.000029         return
                                endif
                            
                                " Do not update when a special buffer is selected
                                if !empty(&l:buftype)
                                    return
                                endif
                            
                                let l:winnr = winnr()
                                let l:altwinnr = winnr('#')
                            
                                call g:NERDTree.CursorToTreeWin()
                                call b:NERDTree.root.refreshFlags()
                                call NERDTreeRender()
                            
                                exec l:altwinnr . 'wincmd w'
                                exec l:winnr . 'wincmd w'

FUNCTION  <SNR>91_get_syn()
Called 12802 times
Total time:   0.273621
 Self time:   0.273621

count  total (s)   self (s)
12802              0.022279   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
12802              0.010451   let color = ''
12802              0.047102   if hlexists(a:group)
12146              0.063008     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
12146              0.006084   endif
12802              0.019487   if empty(color) || color == -1
                                " should always exists
  656              0.004412     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
  656              0.000972     if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
  656              0.000287   endif
12802              0.009552   return color

FUNCTION  airline#highlighter#load_theme()
Called 9 times
Total time:   0.362182
 Self time:   0.000818

count  total (s)   self (s)
    9              0.000040   if pumvisible()
                                return
                              endif
   18              0.000192   for winnr in filter(range(1, winnr('$')), 'v:val != winnr()')
    9   0.004604   0.000143     call airline#highlighter#highlight_modified_inactive(winbufnr(winnr))
    9              0.000019   endfor
    9   0.191963   0.000126   call airline#highlighter#highlight(['inactive'])
    9              0.000058   if getbufvar( bufnr('%'), '&modified'  )
    9   0.165157   0.000091     call airline#highlighter#highlight(['normal', 'modified'])
    9              0.000005   else
                                call airline#highlighter#highlight(['normal'])
                              endif

FUNCTION  airline#update_statusline_inactive()
Called 23 times
Total time:   0.206172
 Self time:   0.001322

count  total (s)   self (s)
   23   0.000242   0.000144   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
   51              0.000091   for nr in a:range
   28   0.000264   0.000147     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
   28              0.000115     call setwinvar(nr, 'airline_active', 0)
   28              0.000167     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
   28   0.204951   0.000316     call s:invoke_funcrefs(context, s:inactive_funcrefs)
   28              0.000021   endfor

FUNCTION  <SNR>101_buffer_commit()
Called 9 times
Total time:   0.000255
 Self time:   0.000063

count  total (s)   self (s)
    9   0.000254   0.000062   return matchstr(self.spec(),'^fugitive:\%(//\)\=.\{-\}\%(//\|::\)\zs\w*')

FUNCTION  <SNR>82_update_git_branch()
Called 2196 times
Total time:   0.377221
 Self time:   0.031798

count  total (s)   self (s)
 2196   0.010601   0.004635   if !airline#util#has_fugitive()
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
 2196   0.351983   0.012526   let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
 2196              0.005339   if s:vcs_config['git'].branch is# 'master' && winwidth(0) < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
                              endif

FUNCTION  <SNR>95_build_sections()
Called 92 times
Total time:   0.019549
 Self time:   0.003545

count  total (s)   self (s)
  460              0.000456   for key in a:keys
  368              0.000732     if (key == 'warning' || key == 'error') && !a:context.active
   56              0.000042       continue
                                endif
  312   0.017195   0.001191     call s:add_section(a:builder, a:context, key)
  312              0.000190   endfor

FUNCTION  <SNR>84_airline_ale_get_line_number()
Called 2204 times
Total time:   0.059129
 Self time:   0.049168

count  total (s)   self (s)
 2204              0.001695   if a:cnt == 0
   18              0.000011     return ''
                              endif
                            
 2186              0.002804   let buffer       = bufnr('')
 2186              0.003310   let problem_type = (a:type ==# 'error') ? 'E' : 'W'
 2186   0.016616   0.006655   let problems     = copy(ale#engine#GetLoclist(buffer))
                            
 2186              0.009961   call filter(problems, 'v:val.bufnr is buffer && v:val.type is# problem_type')
                            
 2186              0.002335   if empty(problems)
                                return ''
                              endif
                            
 2186              0.004872   let open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
 2186              0.004203   let close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
 2186              0.005645   return open_lnum_symbol . problems[0].lnum . close_lnum_symbol

FUNCTION  FugitiveHead()
Called 2196 times
Total time:   0.339457
 Self time:   0.018935

count  total (s)   self (s)
 2196   0.013725   0.006317   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
 2196              0.002341   if empty(dir)
                                return ''
                              endif
 2196   0.320374   0.007260   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  <SNR>128_get_cmd_part()
Called 474 times
Total time:   0.220520
 Self time:   0.018534

count  total (s)   self (s)
  474   0.002709   0.001139   let l:save_pos = vimtex#pos#get_cursor()
  474   0.007950   0.001250   call vimtex#pos#set_cursor(a:start_pos)
  474   0.153782   0.001464   let l:open = vimtex#delim#get_next('delim_tex', 'open')
  474   0.010722   0.001907   call vimtex#pos#set_cursor(l:save_pos)
                            
                              "
                              " Ensure that the delimiter
                              " 1) exists,
                              " 2) is of the right type,
                              " 3) and is the next non-whitespace character.
                              "
  474   0.014906   0.009265   if empty(l:open) || l:open.match !=# a:part || strlen(substitute(        s:text_between(a:start_pos, l:open), '\_s', '', 'g')) != 0
  283              0.000244     return {}
                              endif
                            
  191   0.024507   0.000678   let l:close = vimtex#delim#get_matching(l:open)
  191              0.000236   if empty(l:close)
                                return {}
                              endif
                            
  191   0.004055   0.000942   return { 'open' : l:open, 'close' : l:close, 'text' : s:text_between(l:open, l:close),}

FUNCTION  <SNR>82_update_untracked()
Called 2196 times
Total time:   0.160737
 Self time:   0.142790

count  total (s)   self (s)
 2196              0.037125   let file = expand("%:p")
 2196              0.022849   if empty(file) || isdirectory(file)
                                return
                              endif
                            
 2196              0.002819   let needs_update = 1
 6588              0.008001   for vcs in keys(s:vcs_config)
 4392              0.013047     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
                                endif
 4392              0.007847     if has_key(s:vcs_config[vcs].untracked, file)
 2196              0.001920       let needs_update = 0
 2196   0.032485   0.014538       call airline#extensions#branch#update_untracked_config(file, vcs)
 2196              0.000913     endif
 4392              0.001972   endfor
                            
 2196              0.001507   if !needs_update
 2196              0.001266     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                let config = s:vcs_config[vcs]
                                if g:airline#init#vim_async
                                  " Note that asynchronous update updates s:vcs_config only, and only
                                  " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                  " invalidated again before s:update_untracked is called, then we lose the
                                  " result of the previous call, i.e. the head string is not updated. It
                                  " doesn't happen often in practice, so we let it be.
                                  noa call airline#async#vim_vcs_untracked(config, file)
                                else
                                  " nvim async or vim without job-feature
                                  noa call airline#async#nvim_vcs_untracked(config, file, vcs)
                                endif
                              endfor

FUNCTION  airline#highlighter#highlight()
Called 33 times
Total time:   0.657337
 Self time:   0.070108

count  total (s)   self (s)
   33              0.000082   let bufnr = a:0 ? a:1 : ''
   33              0.000134   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   33              0.000342   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   33              0.000097   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   89              0.000135   for mode in mapped
   56              0.000152     if mode == 'inactive' && winnr('$') == 1
                                  " there exist no inactive windows, don't need to create all those
                                  " highlighting groups
                                  continue
                                endif
   56              0.000275     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   56              0.000166       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  767              0.001133       for kvp in items(dict)
  711              0.001256         let mode_colors = kvp[1]
  711              0.000967         let name = kvp[0]
  711              0.001461         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
   10              0.000010           let name = 'airline_c'.bufnr
   10              0.000003         endif
  711   0.113214   0.003329         call airline#highlighter#exec(name.suffix, mode_colors)
                            
 2133              0.002871         for accent in keys(s:accents)
 1422              0.002565           if !has_key(p.accents, accent)
                                        continue
                                      endif
 1422              0.003370           let colors = copy(mode_colors)
 1422              0.002737           if p.accents[accent][0] != ''
  711              0.001411             let colors[0] = p.accents[accent][0]
  711              0.000341           endif
 1422              0.002021           if p.accents[accent][2] != ''
  711              0.001164             let colors[2] = p.accents[accent][2]
  711              0.000315           endif
 1422              0.001757           if len(colors) >= 5
 1422              0.003254             let colors[4] = get(p.accents[accent], 4, '')
 1422              0.000760           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
 1422   0.231083   0.007175           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
 1422              0.000948         endfor
  711              0.000386       endfor
                            
                                  " TODO: optimize this
  840              0.001110       for sep in items(s:separators)
  784   0.258636   0.005200         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  784              0.000575       endfor
   56              0.000053     endif
   56              0.000044   endfor

FUNCTION  <SNR>97_DisableOnLargeFile()
Called 865 times
Total time:   0.003196
 Self time:   0.003196

count  total (s)   self (s)
  865              0.001744   if exists( 'b:ycm_largefile' )
  865              0.000889     return b:ycm_largefile
                              endif
                            
                              let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
                              let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
                              if b:ycm_largefile
                                exec s:python_command "vimsupport.PostVimMessage(" . "'YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM options).' )"
                              endif
                              return b:ycm_largefile

FUNCTION  airline#parts#ffenc()
Called 2218 times
Total time:   0.036834
 Self time:   0.036834

count  total (s)   self (s)
 2218              0.005067   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
 2218              0.002955   let bomb     = &l:bomb ? '[BOM]' : ''
 2218              0.012139   let ff       = strlen(&ff) ? '['.&ff.']' : ''
 2218              0.007005   if expected is# &fenc.bomb.ff
                                return ''
                              else
 2218              0.005550     return &fenc.bomb.ff
                              endif

FUNCTION  ale#Var()
Called 865 times
Total time:   0.008332
 Self time:   0.008332

count  total (s)   self (s)
  865              0.001709     let l:full_name = 'ale_' . a:variable_name
  865              0.003427     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
  865              0.002700     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  vimtex#delim#get_current()
Called 861 times
Total time:   0.480667
 Self time:   0.007600

count  total (s)   self (s)
  861   0.480388   0.007321   return s:get_delim(extend({ 'direction' : 'current', 'type' : a:type, 'side' : a:side,}, get(a:, '1', {})))

FUNCTION  airline#util#ignore_buf()
Called 2178 times
Total time:   0.073130
 Self time:   0.073130

count  total (s)   self (s)
 2178              0.009418   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  'gundo|undotree|vimfiler|tagbar|nerd_tree|startify|!')
 2178              0.062684   return match(a:name, pat) > -1

FUNCTION  <SNR>131_get_matching_tex()
Called 24 times
Total time:   0.000475
 Self time:   0.000475

count  total (s)   self (s)
   24              0.000152   let [re, flags, stopline] = self.is_open ? [self.re.open,  'nW', line('.') + s:stopline] : [self.re.open, 'bnW', max([line('.') - s:stopline, 1])]
                            
   24              0.000139   let [lnum, cnum] = searchpos(re, flags, stopline)
   24              0.000124   let match = matchstr(getline(lnum), '^' . re, cnum-1)
                            
   24              0.000040   return [match, lnum, cnum]

FUNCTION  vimtex#pos#get_cursor()
Called 2644 times
Total time:   0.009116
 Self time:   0.009116

count  total (s)   self (s)
 2644              0.008513   return exists('*getcurpos') ? getcurpos() : getpos('.')

FUNCTION  airline#builder#get_prev_group()
Called 358 times
Total time:   0.003100
 Self time:   0.003100

count  total (s)   self (s)
  358              0.000522   let x = a:i - 1
  404              0.000378   while x >= 0
  358              0.000694     let group = a:sections[x][0]
  358              0.000476     if group != '' && group != '|'
  312              0.000300       return group
                                endif
   46              0.000056     let x = x - 1
   46              0.000028   endwhile
   46              0.000043   return ''

FUNCTION  <SNR>82_display_git_branch()
Called 9 times
Total time:   0.000573
 Self time:   0.000182

count  total (s)   self (s)
    9              0.000015   let name = b:buffer_vcs_config['git'].branch
    9              0.000005   try
    9   0.000434   0.000043     let commit = fugitive#buffer().commit()
                            
    9              0.000015     if has_key(s:names, commit)
                                  let name = get(s:names, commit)."(".name.")"
                                elseif !empty(commit)
                                  let ref = fugitive#repo().git_chomp('describe', '--all', '--exact-match', commit)
                                  if ref !~ "^fatal: no tag exactly matches"
                                    let name = s:format_name(substitute(ref, '\v\C^%(heads/|remotes/|tags/)=','',''))."(".name.")"
                                  else
                                    let name = matchstr(commit, '.\{'.s:sha1size.'}')."(".name.")"
                                  endif
                                endif
    9              0.000003   catch
                              endtry
                            
    9              0.000005   return name

FUNCTION  airline#extensions#wordcount#formatters#default#update_fmt()
Called 18 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
   18              0.000042   let s:fmt = get(g:, 'airline#extensions#wordcount#formatter#default#fmt', '%s words')
   18              0.000041   let s:fmt_short = get(g:, 'airline#extensions#wordcount#formatter#default#fmt_short', s:fmt == '%s words' ? '%sW' : s:fmt)

FUNCTION  airline#load_theme()
Called 9 times
Total time:   0.482145
 Self time:   0.001236

count  total (s)   self (s)
    9              0.000108   let g:airline_theme = get(g:, 'airline_theme', 'dark')
    9              0.000122   if exists('*airline#themes#{g:airline_theme}#refresh')
    9   0.014371   0.000341     call airline#themes#{g:airline_theme}#refresh()
    9              0.000013   endif
                            
    9              0.000069   let palette = g:airline#themes#{g:airline_theme}#palette
    9   0.005363   0.000186   call airline#themes#patch(palette)
                            
    9              0.000051   if exists('g:airline_theme_patch_func')
                                let Fn = function(g:airline_theme_patch_func)
                                call Fn(palette)
                              endif
                            
    9   0.362325   0.000143   call airline#highlighter#load_theme()
    9   0.000163   0.000045   call airline#extensions#load_theme()
    9   0.099435   0.000033   call airline#update_statusline()

FUNCTION  <SNR>131_parser_env()
Called 158 times
Total time:   0.089202
 Self time:   0.007330

count  total (s)   self (s)
  158              0.000191   let result = {}
                            
  158              0.000227   let result.type = 'env'
  158              0.001857   let result.name = matchstr(a:match, '{\zs\k*\ze\*\?}')
  158              0.000573   let result.starred = match(a:match, '\*}$') > 0
  158              0.000446   let result.side = a:match =~# '\\begin' ? 'open' : 'close'
  158              0.000259   let result.is_open = result.side ==# 'open'
  158              0.000578   let result.get_matching = function('s:get_matching_env')
                            
  158              0.000139   if result.is_open
   59   0.082064   0.000192     let result.env_cmd = vimtex#cmd#get_at(a:lnum, a:cnum)
   59              0.000022   endif
                            
  158              0.000944   let result.corr = result.is_open ? substitute(a:match, 'begin', 'end', '') : substitute(a:match, 'end', 'begin', '')
                            
  158              0.000542   let result.re = { 'open' : '\m\\begin\s*{' . result.name . '\*\?}', 'close' : '\m\\end\s*{' . result.name . '\*\?}',}
                            
  158              0.000337   let result.re.this = result.is_open ? result.re.open  : result.re.close
  158              0.000263   let result.re.corr = result.is_open ? result.re.close : result.re.open
                            
  158              0.000141   return result

FUNCTION  airline#extensions#prepend_to_section()
Called 18 times
Total time:   0.000213
 Self time:   0.000103

count  total (s)   self (s)
   18   0.000159   0.000049   call <sid>check_defined_section(a:name)
   18              0.000046   let w:airline_section_{a:name} = a:value . w:airline_section_{a:name}

FUNCTION  airline#parts#paste()
Called 2178 times
Total time:   0.003823
 Self time:   0.003823

count  total (s)   self (s)
 2178              0.003366   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>131_get_delim()
Called 1335 times
Total time:   0.622232
 Self time:   0.358328

count  total (s)   self (s)
                              "
                              " Arguments:
                              "   opts = {
                              "     'direction'   :  next
                              "                      prev
                              "                      current
                              "     'type'        :  env_tex
                              "                      env_math
                              "                      env_all
                              "                      delim_tex
                              "                      delim_math
                              "                      delim_modq_math (possibly modified math delimiter)
                              "                      delim_mod_math  (modified math delimiter)
                              "                      delim_all
                              "                      all
                              "     'side'        :  open
                              "                      close
                              "                      both
                              "     'syn_exclude' :  Don't match in given syntax
                              "  }
                              "
                              " Returns:
                              "   delim = {
                              "     type    : env | delim
                              "     side    : open | close
                              "     name    : name of environment [only for type env]
                              "     lnum    : number
                              "     cnum    : number
                              "     match   : unparsed matched delimiter
                              "     corr    : corresponding delimiter
                              "     re : {
                              "       open  : regexp for the opening part
                              "       close : regexp for the closing part
                              "     }
                              "   }
                              "
 1335   0.008757   0.004019   let l:save_pos = vimtex#pos#get_cursor()
 1335              0.003745   let l:re = g:vimtex#delim#re[a:opts.type][a:opts.side]
 1335              0.001231   while 1
 1335              0.192584     let [l:lnum, l:cnum] = a:opts.direction ==# 'next' ? searchpos(l:re, 'cnW', line('.') + s:stopline) : a:opts.direction ==# 'prev'   ? searchpos(l:re, 'bcnW', max([line('.') - s:stopline, 1]))   : searchpos(l:re, 'bcnW', line('.'))
 1335              0.003656     if l:lnum == 0 | break | endif
                            
 1123              0.003577     if has_key(a:opts, 'syn_exclude') && vimtex#util#in_syntax(a:opts.syn_exclude, l:lnum, l:cnum)
                                  call vimtex#pos#set_cursor(vimtex#pos#prev(l:lnum, l:cnum))
                                  continue
                                endif
                            
 1123              0.000620     break
                              endwhile
 1335   0.032225   0.005198   call vimtex#pos#set_cursor(l:save_pos)
                            
 1335              0.037974   let l:match = matchstr(getline(l:lnum), '^' . l:re, l:cnum-1)
                            
 1335              0.006094   if a:opts.direction ==# 'current' && l:cnum + strlen(l:match) + (mode() ==# 'i' ? 1 : 0) <= col('.')
  533              0.000547     let l:match = ''
  533              0.000427     let l:lnum = 0
  533              0.000301     let l:cnum = 0
  533              0.000295   endif
                            
 1335              0.003638   let l:result = { 'type' : '', 'lnum' : l:lnum, 'cnum' : l:cnum, 'match' : l:match,}
                            
 6404              0.005540   for l:type in s:types
 5871              0.037925     if l:match =~# '^' . l:type.re
  802   0.156274   0.014887       let l:result = extend( l:type.parser(l:match, l:lnum, l:cnum,               a:opts.side, a:opts.type, a:opts.direction), l:result, 'keep')
  802              0.000478       break
                                endif
 5069              0.005927   endfor
                            
 1335              0.002803   return empty(l:result.type) ? {} : l:result

FUNCTION  <SNR>131_get_matching_env()
Called 158 times
Total time:   0.011179
 Self time:   0.011179

count  total (s)   self (s)
  158              0.000996   let [re, flags, stopline] = self.is_open ? [self.re.close,  'nW', line('.') + s:stopline] : [self.re.open,  'bnW', max([line('.') - s:stopline, 1])]
                            
  158              0.008328   let [lnum, cnum] = searchpairpos(self.re.open, '', self.re.close, flags, '', stopline)
  158              0.001431   let match = matchstr(getline(lnum), '^' . re, cnum-1)
                            
  158              0.000246   return [match, lnum, cnum]

FUNCTION  airline#update_statusline()
Called 18 times
Total time:   0.196226
 Self time:   0.000660

count  total (s)   self (s)
   18   0.000094   0.000050   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
   18              0.000083   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
   18   0.081599   0.000064   call airline#update_statusline_inactive(range)
                            
   18              0.000029   unlet! w:airline_render_left w:airline_render_right
   18              0.000153   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
   18              0.000019   let w:airline_active = 1
   18              0.000058   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
   18   0.114137   0.000150   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  ale#balloon#Expr()
Called 1 time
Total time:   0.001755
 Self time:   0.000049

count  total (s)   self (s)
    1   0.001753   0.000047     return ale#balloon#MessageForPos(v:beval_bufnr, v:beval_lnum, v:beval_col)

FUNCTION  airline#extensions#branch#update_untracked_config()
Called 2196 times
Total time:   0.017947
 Self time:   0.017947

count  total (s)   self (s)
 2196              0.005056   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
                              endif

FUNCTION  <SNR>84_airline_ale_count()
Called 2204 times
Total time:   0.004314
 Self time:   0.004314

count  total (s)   self (s)
 2204              0.003744   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  airline#parts#readonly()
Called 2178 times
Total time:   0.105810
 Self time:   0.032680

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files, 
                              " but not special ones like e.g. NERDTree)
 2178   0.093077   0.019947   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
                              endif
 2178              0.003365   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
 2178              0.002525     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  vimtex#util#in_comment()
Called 864 times
Total time:   1.166762
 Self time:   0.005111

count  total (s)   self (s)
  864   1.166425   0.004774   return call('vimtex#util#in_syntax', ['texComment'] + a:000)

FUNCTION  fugitive#Head()
Called 2196 times
Total time:   0.313114
 Self time:   0.313114

count  total (s)   self (s)
 2196              0.004252   let dir = a:0 > 1 ? a:2 : get(b:, 'git_dir', '')
 2196              0.135015   if empty(dir) || !filereadable(dir . '/HEAD')
                                return ''
                              endif
 2196              0.130438   let head = readfile(dir . '/HEAD')[0]
 2196              0.012325   if head =~# '^ref: '
 2196              0.025006     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  <SNR>131_get_matching_latex()
Called 50 times
Total time:   0.000863
 Self time:   0.000863

count  total (s)   self (s)
   50              0.000273   let [re, flags, stopline] = self.is_open ? [self.re.close, 'nW', line('.') + s:stopline] : [self.re.open, 'bnW', max([line('.') - s:stopline, 1])]
                            
   50              0.000247   let [lnum, cnum] = searchpos(re, flags, stopline)
   50              0.000233   let match = matchstr(getline(lnum), '^' . re, cnum-1)
                            
   50              0.000061   return [match, lnum, cnum]

FUNCTION  airline#builder#should_change_group()
Called 202 times
Total time:   0.040151
 Self time:   0.002828

count  total (s)   self (s)
  202              0.000267   if a:group1 == a:group2
                                return 0
                              endif
  202   0.019993   0.000696   let color1 = airline#highlighter#get_highlight(a:group1)
  202   0.018733   0.000707   let color2 = airline#highlighter#get_highlight(a:group2)
  202              0.000204   if g:airline_gui_mode ==# 'gui'
  202              0.000578     return color1[1] != color2[1] || color1[0] != color2[0]
                              else
                                return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  airline#highlighter#exec()
Called 3437 times
Total time:   0.512777
 Self time:   0.151059

count  total (s)   self (s)
 3437              0.004154   if pumvisible()
                                return
                              endif
 3437              0.003893   let colors = a:colors
 3437              0.003104   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
 3437   0.303582   0.015513   let old_hi = airline#highlighter#get_highlight(a:group)
 3437              0.004805   if len(colors) == 4
 1351              0.002478     call add(colors, '')
 1351              0.000635   endif
 3437              0.003223   if g:airline_gui_mode ==# 'gui'
 3437              0.010803     let new_hi = [colors[0], colors[1], '', '', colors[4]]
 3437              0.001685   else
                                let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
                              endif
 3437   0.046135   0.012710   let colors = s:CheckDefined(colors)
 3437   0.046213   0.011780   if old_hi != new_hi || !s:hl_group_exists(a:group)
  216   0.011382   0.005591     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg='), s:Get(colors, 1, 'guibg='), s:Get(colors, 2, 'ctermfg='), s:Get(colors, 3, 'ctermbg='), s:Get(colors, 4, 'gui='), s:Get(colors, 4, 'cterm='), s:Get(colors, 4, 'term='))
  216              0.001973     exe cmd
  216              0.000394     if has_key(s:hl_groups, a:group)
  216              0.000355       let s:hl_groups[a:group] = colors
  216              0.000091     endif
  216              0.000078   endif

FUNCTION  <SNR>101_buffer_spec()
Called 42 times
Total time:   0.000726
 Self time:   0.000571

count  total (s)   self (s)
   42              0.000061     let bufname = bufname(self['#'])
   42   0.000655   0.000500     return s:Slash(bufname == '' ? '' : fnamemodify(bufname,':p'))

FUNCTION  271()
Called 312 times
Total time:   0.000932
 Self time:   0.000932

count  total (s)   self (s)
  312              0.000868   call add(self._sections, [a:group, a:contents])

FUNCTION  vimtex#pos#val()
Called 316 times
Total time:   0.005779
 Self time:   0.002094

count  total (s)   self (s)
  316   0.004840   0.001155   let [l:lnum, l:cnum; l:rest] = s:parse_args(a:000)
                            
  316              0.000771   return 100000*l:lnum + min([l:cnum, 90000])

FUNCTION  <SNR>91_hl_group_exists()
Called 3221 times
Total time:   0.034433
 Self time:   0.034433

count  total (s)   self (s)
 3221              0.011432   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
 3221              0.002013   return 1

FUNCTION  fugitive#ReloadStatus()
Called 5 times
Total time:   0.000466
 Self time:   0.000466

count  total (s)   self (s)
    5              0.000011   if exists('s:reloading_status')
                                return
                              endif
    5              0.000002   try
    5              0.000007     let s:reloading_status = 1
    5              0.000006     let mytab = tabpagenr()
   15              0.000021     for tab in [mytab] + range(1,tabpagenr('$'))
   30              0.000031       for winnr in range(1,tabpagewinnr(tab,'$'))
   20              0.000056         if getbufvar(tabpagebuflist(tab)[winnr-1],'fugitive_type') ==# 'index'
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        if !&modified
                                          call fugitive#BufReadStatus()
                                        endif
                                      finally
                                        if exists('restorewinnr')
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                    endif
   20              0.000006       endfor
   10              0.000005     endfor
    5              0.000003   finally
    5              0.000007     unlet! s:reloading_status
    5              0.000003   endtry

FUNCTION  <SNR>128_get_cmd_name()
Called 158 times
Total time:   0.002949
 Self time:   0.002949

count  total (s)   self (s)
  158              0.001475   let [l:lnum, l:cnum] = searchpos('\v\\\a+\*?', a:next ? 'nW' : 'cbnW')
  158              0.001135   let l:match = matchstr(getline(l:lnum), '^\v\\\a*\*?', l:cnum-1)
  158              0.000278   return [l:lnum, l:cnum, l:match]

FUNCTION  <SNR>101_Slash()
Called 42 times
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
   42              0.000058   if exists('+shellslash')
                                return tr(a:path, '\', '/')
                              else
   42              0.000025     return a:path
                              endif

FUNCTION  <SNR>77_is_excluded_window()
Called 46 times
Total time:   0.001978
 Self time:   0.001978

count  total (s)   self (s)
   46              0.000105   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
  184              0.000207   for matchw in g:airline_exclude_filenames
  138              0.000771     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
  138              0.000095   endfor
                            
   46              0.000069   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
   46              0.000041   return 0

FUNCTION  airline#parts#spell()
Called 2178 times
Total time:   0.031715
 Self time:   0.031715

count  total (s)   self (s)
 2178              0.013987   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
 2178              0.002419   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
 2178              0.001162   return ''

FUNCTION  airline#themes#solarized#refresh()
Called 9 times
Total time:   0.014030
 Self time:   0.009917

count  total (s)   self (s)
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Options
                              """"""""""""""""""""""""""""""""""""""""""""""""
    9              0.000110   let s:background           = get(g:, 'airline_solarized_bg', &background)
    9              0.000096   let s:ansi_colors          = get(g:, 'solarized_termcolors', 16) != 256 && &t_Co >= 16 ? 1 : 0
    9              0.000065   let s:use_green            = get(g:, 'airline_solarized_normal_green', 0)
    9              0.000054   let s:dark_text            = get(g:, 'airline_solarized_dark_text', 0)
    9              0.000067   let s:dark_inactive_border = get(g:, 'airline_solarized_dark_inactive_border', 0)
    9              0.000046   let s:tty                  = &t_Co == 8
                            
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Colors
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Base colors
                              " Extended base16 support by @cuviper.
                              " Via https://github.com/blueyed/vim-colors-solarized/commit/92f2f994 /
                              " https://github.com/cuviper/vim-colors-solarized.
    9              0.000053   if s:ansi_colors && get(g:, 'solarized_base16', 0)
                                let s:base03  = {'t': 0,  'g': "#002b36"}  " Base 00
                                let s:base02  = {'t': 18, 'g': "#073642"}  " Base 01
                                let s:base01  = {'t': 19, 'g': "#586e75"}  " Base 02
                                let s:base00  = {'t': 8,  'g': "#657b83"}  " Base 03
                                let s:base0   = {'t': 20, 'g': "#839496"}  " Base 04
                                let s:base1   = {'t': 7,  'g': "#93a1a1"}  " Base 05
                                let s:base2   = {'t': 21, 'g': "#eee8d5"}  " Base 06
                                let s:base3   = {'t': 15, 'g': "#fdf6e3"}  " Base 07
                                let s:yellow  = {'t': 3,  'g': "#dc322f"}  " Base 0A
                                let s:orange  = {'t': 16, 'g': "#cb4b16"}  " Base 09
                                let s:red     = {'t': 1,  'g': "#b58900"}  " Base 08
                                let s:magenta = {'t': 17, 'g': "#859900"}  " Base 0F
                                let s:violet  = {'t': 5,  'g': "#2aa198"}  " Base 0E
                                let s:blue    = {'t': 4,  'g': "#268bd2"}  " Base 0D
                                let s:cyan    = {'t': 6,  'g': "#6c71c4"}  " Base 0C
                                let s:green   = {'t': 2,  'g': "#d33682"}  " Base 0B
                              else
    9              0.000105     let s:base03  = {'t': s:ansi_colors ?   8 : (s:tty ? '0' : 234), 'g': '#002b36'}
    9              0.000069     let s:base02  = {'t': s:ansi_colors ? '0' : (s:tty ? '0' : 235), 'g': '#073642'}
    9              0.000072     let s:base01  = {'t': s:ansi_colors ?  10 : (s:tty ? '0' : 240), 'g': '#586e75'}
    9              0.000059     let s:base00  = {'t': s:ansi_colors ?  11 : (s:tty ? '7' : 241), 'g': '#657b83'}
    9              0.000070     let s:base0   = {'t': s:ansi_colors ?  12 : (s:tty ? '7' : 244), 'g': '#839496'}
    9              0.000060     let s:base1   = {'t': s:ansi_colors ?  14 : (s:tty ? '7' : 245), 'g': '#93a1a1'}
    9              0.000064     let s:base2   = {'t': s:ansi_colors ?   7 : (s:tty ? '7' : 254), 'g': '#eee8d5'}
    9              0.000062     let s:base3   = {'t': s:ansi_colors ?  15 : (s:tty ? '7' : 230), 'g': '#fdf6e3'}
    9              0.000057     let s:yellow  = {'t': s:ansi_colors ?   3 : (s:tty ? '3' : 136), 'g': '#b58900'}
    9              0.000059     let s:orange  = {'t': s:ansi_colors ?   9 : (s:tty ? '1' : 166), 'g': '#cb4b16'}
    9              0.000055     let s:red     = {'t': s:ansi_colors ?   1 : (s:tty ? '1' : 160), 'g': '#dc322f'}
    9              0.000061     let s:magenta = {'t': s:ansi_colors ?   5 : (s:tty ? '5' : 125), 'g': '#d33682'}
    9              0.000064     let s:violet  = {'t': s:ansi_colors ?  13 : (s:tty ? '5' : 61 ), 'g': '#6c71c4'}
    9              0.000060     let s:blue    = {'t': s:ansi_colors ?   4 : (s:tty ? '4' : 33 ), 'g': '#268bd2'}
    9              0.000060     let s:cyan    = {'t': s:ansi_colors ?   6 : (s:tty ? '6' : 37 ), 'g': '#2aa198'}
    9              0.000060     let s:green   = {'t': s:ansi_colors ?   2 : (s:tty ? '2' : 64 ), 'g': '#859900'}
    9              0.000018   endif
                            
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Simple mappings
                              " NOTE: These are easily tweakable mappings. The actual mappings get
                              " the specific gui and terminal colors from the base color dicts.
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Normal mode
    9              0.000035   if s:background == 'dark'
    9              0.000095     let s:N1 = [(s:dark_text ? s:base03 : s:base3), (s:use_green ? s:green : s:base1), 'bold']
    9              0.000053     let s:N2 = [s:base2, (s:tty ? s:base01 : s:base00), '']
    9              0.000043     let s:N3 = [s:base01, s:base02, '']
    9              0.000015   else
                                let s:N1 = [(s:dark_text ? s:base03 : s:base2), (s:use_green ? s:green : s:base00), 'bold']
                                let s:N2 = [(s:tty ? s:base01 : s:base2), s:base1, '']
                                let s:N3 = [s:base1, s:base2, '']
                              endif
    9              0.000080   let s:NF = [s:orange, s:N3[1], '']
    9              0.000054   let s:NW = [s:base3, s:orange, '']
    9              0.000030   if s:background == 'dark'
    9              0.000042     let s:NM = [s:base1, s:N3[1], '']
    9              0.000059     let s:NMi = [s:base2, s:N3[1], '']
    9              0.000013   else
                                let s:NM = [s:base01, s:N3[1], '']
                                let s:NMi = [s:base02, s:N3[1], '']
                              endif
                            
                              " Insert mode
    9              0.000063   let s:I1 = [s:N1[0], s:yellow, 'bold']
    9              0.000024   let s:I2 = s:N2
    9              0.000022   let s:I3 = s:N3
    9              0.000026   let s:IF = s:NF
    9              0.000020   let s:IM = s:NM
                            
                              " Visual mode
    9              0.000058   let s:V1 = [s:N1[0], s:magenta, 'bold']
    9              0.000023   let s:V2 = s:N2
    9              0.000019   let s:V3 = s:N3
    9              0.000021   let s:VF = s:NF
    9              0.000022   let s:VM = s:NM
                            
                              " Replace mode
    9              0.000062   let s:R1 = [s:N1[0], s:red, '']
    9              0.000033   let s:R2 = s:N2
    9              0.000032   let s:R3 = s:N3
    9              0.000031   let s:RM = s:NM
    9              0.000035   let s:RF = s:NF
                            
                              " Inactive, according to VertSplit in solarized
                              " (bg dark: base00; bg light: base0)
    9              0.000025   if s:background == 'dark'
    9              0.000027     if s:dark_inactive_border
                                  let s:IA = [s:base01, s:base02, '']
                                else
    9              0.000059       let s:IA = [s:base02, s:base00, '']
    9              0.000014     endif
    9              0.000014   else
                                let s:IA = [s:base2, s:base0, '']
                              endif
                            
                              """"""""""""""""""""""""""""""""""""""""""""""""
                              " Actual mappings
                              " WARNING: Don't modify this section unless necessary.
                              """"""""""""""""""""""""""""""""""""""""""""""""
    9              0.000112   let s:NFa = [s:NF[0].g, s:NF[1].g, s:NF[0].t, s:NF[1].t, s:NF[2]]
    9              0.000113   let s:IFa = [s:IF[0].g, s:IF[1].g, s:IF[0].t, s:IF[1].t, s:IF[2]]
    9              0.000094   let s:VFa = [s:VF[0].g, s:VF[1].g, s:VF[0].t, s:VF[1].t, s:VF[2]]
    9              0.000091   let s:RFa = [s:RF[0].g, s:RF[1].g, s:RF[0].t, s:RF[1].t, s:RF[2]]
                            
    9              0.000259   let g:airline#themes#solarized#palette.accents = { 'red': s:NFa, }
                            
    9   0.001732   0.000769   let g:airline#themes#solarized#palette.inactive = airline#themes#generate_color_map( [s:IA[0].g, s:IA[1].g, s:IA[0].t, s:IA[1].t, s:IA[2]], [s:IA[0].g, s:IA[1].g, s:IA[0].t, s:IA[1].t, s:IA[2]], [s:IA[0].g, s:IA[1].g, s:IA[0].t, s:IA[1].t, s:IA[2]])
    9              0.000303   let g:airline#themes#solarized#palette.inactive_modified = { 'airline_c': [s:NMi[0].g, '', s:NMi[0].t, '', s:NMi[2]]}
                            
    9   0.001627   0.000803   let g:airline#themes#solarized#palette.normal = airline#themes#generate_color_map( [s:N1[0].g, s:N1[1].g, s:N1[0].t, s:N1[1].t, s:N1[2]], [s:N2[0].g, s:N2[1].g, s:N2[0].t, s:N2[1].t, s:N2[2]], [s:N3[0].g, s:N3[1].g, s:N3[0].t, s:N3[1].t, s:N3[2]])
                            
    9              0.000132   let g:airline#themes#solarized#palette.normal.airline_warning = [ s:NW[0].g, s:NW[1].g, s:NW[0].t, s:NW[1].t, s:NW[2]]
                            
    9              0.000108   let g:airline#themes#solarized#palette.normal.airline_error = [ s:NW[0].g, s:NW[1].g, s:NW[0].t, s:NW[1].t, s:NW[2]]
                            
    9              0.000318   let g:airline#themes#solarized#palette.normal_modified = { 'airline_c': [s:NM[0].g, s:NM[1].g, s:NM[0].t, s:NM[1].t, s:NM[2]]}
                            
    9              0.000077   let g:airline#themes#solarized#palette.normal_modified.airline_warning = g:airline#themes#solarized#palette.normal.airline_warning
                            
    9   0.001555   0.000730   let g:airline#themes#solarized#palette.insert = airline#themes#generate_color_map( [s:I1[0].g, s:I1[1].g, s:I1[0].t, s:I1[1].t, s:I1[2]], [s:I2[0].g, s:I2[1].g, s:I2[0].t, s:I2[1].t, s:I2[2]], [s:I3[0].g, s:I3[1].g, s:I3[0].t, s:I3[1].t, s:I3[2]])
                            
    9              0.000065   let g:airline#themes#solarized#palette.insert.airline_warning = g:airline#themes#solarized#palette.normal.airline_warning
                            
    9              0.000151   let g:airline#themes#solarized#palette.insert_modified = { 'airline_c': [s:IM[0].g, s:IM[1].g, s:IM[0].t, s:IM[1].t, s:IM[2]]}
                            
    9              0.000057   let g:airline#themes#solarized#palette.insert_modified.airline_warning = g:airline#themes#solarized#palette.normal.airline_warning
                            
    9   0.001295   0.000519   let g:airline#themes#solarized#palette.visual = airline#themes#generate_color_map( [s:V1[0].g, s:V1[1].g, s:V1[0].t, s:V1[1].t, s:V1[2]], [s:V2[0].g, s:V2[1].g, s:V2[0].t, s:V2[1].t, s:V2[2]], [s:V3[0].g, s:V3[1].g, s:V3[0].t, s:V3[1].t, s:V3[2]])
                            
    9              0.000060   let g:airline#themes#solarized#palette.visual.airline_warning = g:airline#themes#solarized#palette.normal.airline_warning
                            
    9              0.000138   let g:airline#themes#solarized#palette.visual_modified = { 'airline_c': [s:VM[0].g, s:VM[1].g, s:VM[0].t, s:VM[1].t, s:VM[2]]}
                            
    9              0.000054   let g:airline#themes#solarized#palette.visual_modified.airline_warning = g:airline#themes#solarized#palette.normal.airline_warning
                            
    9   0.001162   0.000437   let g:airline#themes#solarized#palette.replace = airline#themes#generate_color_map( [s:R1[0].g, s:R1[1].g, s:R1[0].t, s:R1[1].t, s:R1[2]], [s:R2[0].g, s:R2[1].g, s:R2[0].t, s:R2[1].t, s:R2[2]], [s:R3[0].g, s:R3[1].g, s:R3[0].t, s:R3[1].t, s:R3[2]])
                            
    9              0.000060   let g:airline#themes#solarized#palette.replace.airline_warning = g:airline#themes#solarized#palette.normal.airline_warning
                            
    9              0.000153   let g:airline#themes#solarized#palette.replace_modified = { 'airline_c': [s:RM[0].g, s:RM[1].g, s:RM[0].t, s:RM[1].t, s:RM[2]]}
                            
    9              0.000054   let g:airline#themes#solarized#palette.replace_modified.airline_warning = g:airline#themes#solarized#palette.normal.airline_warning
                            
    9              0.000087   let g:airline#themes#solarized#palette.tabline = {}
                            
    9              0.000099   let g:airline#themes#solarized#palette.tabline.airline_tab = [ s:I2[0].g, s:I2[1].g, s:I2[0].t, s:I2[1].t, s:I2[2]]
                            
    9              0.000095   let g:airline#themes#solarized#palette.tabline.airline_tabtype = [ s:N2[0].g, s:N2[1].g, s:N2[0].t, s:N2[1].t, s:N2[2]]

FUNCTION  <SNR>79_invoke_funcrefs()
Called 46 times
Total time:   0.318622
 Self time:   0.001525

count  total (s)   self (s)
   46   0.001210   0.000224   let builder = airline#builder#new(a:context)
   46   0.031723   0.000398   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   46              0.000042   if err == 1
   46   0.285043   0.000257     let a:context.line = builder.build()
   46              0.000202     let s:contexts[a:context.winnr] = a:context
   46              0.000331     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
   46              0.000021   endif

FUNCTION  ale#linter#GetAll()
Called 1 time
Total time:   0.000143
 Self time:   0.000106

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
    1   0.000047   0.000010     if ale#util#InSandbox()
                                    return []
                                endif
                            
    1              0.000005     let l:combined_linters = []
                            
    2              0.000011     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
    1              0.000008         if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
                                    endif
                            
    1              0.000017         call extend(l:combined_linters, get(s:linters, l:filetype, []))
    1              0.000002     endfor
                            
    1              0.000004     return l:combined_linters

FUNCTION  <SNR>131_parser_tex()
Called 24 times
Total time:   0.045378
 Self time:   0.000932

count  total (s)   self (s)
                              "
                              " TeX shorthand are these
                              "
                              "   $ ... $   (inline math)
                              "   $$ ... $$ (displayed equations)
                              "
                              " The notation does not provide the delimiter side directly, which provides
                              " a slight problem. However, we can utilize the syntax information to parse
                              " the side.
                              "
   24              0.000026   let result = {}
   24              0.000029   let result.type = 'env'
   24              0.000025   let result.corr = a:match
   24              0.000084   let result.get_matching = function('s:get_matching_tex')
   24              0.000152   let result.re = { 'this'  : '\m' . escape(a:match, '$'), 'corr'  : '\m' . escape(a:match, '$'), 'open'  : '\m' . escape(a:match, '$'), 'close' : '\m' . escape(a:match, '$'),}
   24   0.044596   0.000150   let result.side = vimtex#util#in_syntax(   (a:match ==# '$' ? 'texMathZoneX' : 'texMathZoneY'),   a:lnum, a:cnum+1) ? 'open' : 'close'
   24              0.000065   let result.is_open = result.side ==# 'open'
                            
   24              0.000043   if (a:side !=# 'both') && (a:side !=# result.side)
                                "
                                " The current match ($ or $$) is not the correct side, so we must
                                " continue the search recursively. We do this by changing the cursor
                                " position, since the function searchpos relies on the current cursor
                                " position.
                                "
                                let l:save_pos = vimtex#pos#get_cursor()
                            
                                " Move the cursor
                                call vimtex#pos#set_cursor(a:direction ==# 'next' ? vimtex#pos#next(a:lnum, a:cnum) : vimtex#pos#prev(a:lnum, a:cnum))
                            
                                " Get new result
                                let result = s:get_delim({ 'direction' : a:direction, 'type' : a:type, 'side' : a:side,})
                            
                                " Restore the cursor
                                call vimtex#pos#set_cursor(l:save_pos)
                              endif
                            
   24              0.000022   return result

FUNCTION  <SNR>131_get_matching_delim()
Called 287 times
Total time:   0.011157
 Self time:   0.011157

count  total (s)   self (s)
  287              0.001673   let [re, flags, stopline] = self.is_open ? [self.re.close,  'nW', line('.') + s:stopline] : [self.re.open,  'bnW', max([line('.') - s:stopline, 1])]
                            
  287              0.007075   let [lnum, cnum] = searchpairpos(self.re.open, '', self.re.close, flags, '', stopline)
  287              0.001677   let match = matchstr(getline(lnum), '^' . re, cnum-1)
                            
  287              0.000436   return [match, lnum, cnum]

FUNCTION  ale#util#Mode()
Called 85 times
Total time:   0.000403
 Self time:   0.000403

count  total (s)   self (s)
   85              0.000340     return call('mode', a:000)

FUNCTION  <SNR>65_Highlight_Matching_Pair()
Called 865 times
Total time:   0.565936
 Self time:   0.565936

count  total (s)   self (s)
                              " Remove any previous match.
  865              0.002159   if exists('w:paren_hl_on') && w:paren_hl_on
  209              0.000444     silent! call matchdelete(3)
  209              0.000219     let w:paren_hl_on = 0
  209              0.000093   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  865              0.004656   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  865              0.001317   let c_lnum = line('.')
  865              0.001175   let c_col = col('.')
  865              0.000957   let before = 0
                            
  865              0.001488   let text = getline(c_lnum)
  865              0.022804   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  865              0.001340   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  865              0.002618     let [c_before, c] = matches[1:2]
  865              0.000426   endif
  865              0.007680   let plist = split(&matchpairs, '.\zs[:,]')
  865              0.001706   let i = index(plist, c)
  865              0.000668   if i < 0
                                " not found, in Insert mode try character before the cursor
  618              0.001458     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
  618              0.000405     if i < 0
                                  " not found, nothing to do
  618              0.000476       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
  247              0.000217   if i % 2 == 0
   34              0.000025     let s_flags = 'nW'
   34              0.000044     let c2 = plist[i + 1]
   34              0.000019   else
  213              0.000203     let s_flags = 'nbW'
  213              0.000194     let c2 = c
  213              0.000375     let c = plist[i - 1]
  213              0.000093   endif
  247              0.000225   if c == '['
   76              0.000049     let c = '\['
   76              0.000045     let c2 = '\]'
   76              0.000030   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
  247              0.000188   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
  247              0.000652   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
  247              0.238188   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
  247              0.007303   let stoplinebottom = line('w$')
  247              0.004360   let stoplinetop = line('w0')
  247              0.000226   if i % 2 == 0
   34              0.000039     let stopline = stoplinebottom
   34              0.000013   else
  213              0.000290     let stopline = stoplinetop
  213              0.000100   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
  247              0.000497   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
  247              0.000735     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
  247              0.000097   endif
  247              0.000151   try
  247              0.229727     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
  247              0.000395   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
  247              0.000233   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
  247              0.000459   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
  209              0.000385     if exists('*matchaddpos')
  209              0.003465       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
  209              0.000118     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
  209              0.000262     let w:paren_hl_on = 1
  209              0.000087   endif

FUNCTION  <SNR>101_buffer_getvar()
Called 31 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
   31              0.000055   return getbufvar(self['#'],a:var)

FUNCTION  airline#themes#patch()
Called 9 times
Total time:   0.005177
 Self time:   0.005177

count  total (s)   self (s)
  117              0.000334   for mode in keys(a:palette)
  108              0.000523     if !has_key(a:palette[mode], 'airline_warning')
   36              0.000220       let a:palette[mode]['airline_warning'] = [ '#000000', '#df5f00', 232, 166 ]
   36              0.000040     endif
  108              0.000461     if !has_key(a:palette[mode], 'airline_error')
   99              0.000620       let a:palette[mode]['airline_error'] = [ '#000000', '#990000', 232, 160 ]
   99              0.000114     endif
  108              0.000448     if !has_key(a:palette[mode], 'airline_term')
  108              0.000656       let a:palette[mode]['airline_term'] = [ '#9cffd3', '#202020', 85, 232]
  108              0.000122     endif
  108              0.000152   endfor
                            
    9              0.000066   let a:palette.accents = get(a:palette, 'accents', {})
    9              0.000043   let a:palette.accents.none = [ '', '', '', '', '' ]
    9              0.000049   let a:palette.accents.bold = [ '', '', '', '', 'bold' ]
    9              0.000045   let a:palette.accents.italic = [ '', '', '', '', 'italic' ]
                            
    9              0.000044   if !has_key(a:palette.accents, 'red')
                                let a:palette.accents.red = [ '#ff0000' , '' , 160 , '' ]
                              endif
    9              0.000036   if !has_key(a:palette.accents, 'green')
    9              0.000041     let a:palette.accents.green = [ '#008700' , '' , 22  , '' ]
    9              0.000013   endif
    9              0.000032   if !has_key(a:palette.accents, 'blue')
    9              0.000040     let a:palette.accents.blue = [ '#005fff' , '' , 27  , '' ]
    9              0.000010   endif
    9              0.000038   if !has_key(a:palette.accents, 'yellow')
    9              0.000035     let a:palette.accents.yellow = [ '#dfff00' , '' , 190 , '' ]
    9              0.000009   endif
    9              0.000030   if !has_key(a:palette.accents, 'orange')
    9              0.000041     let a:palette.accents.orange = [ '#df5f00' , '' , 166 , '' ]
    9              0.000010   endif
    9              0.000033   if !has_key(a:palette.accents, 'purple')
    9              0.000057     let a:palette.accents.purple = [ '#af00df' , '' , 128 , '' ]
    9              0.000013   endif

FUNCTION  <SNR>82_format_name()
Called 9 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    9              0.000007     return a:name

FUNCTION  <SNR>86_update_wordcount()
Called 1 time
Total time:   0.000075
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000071   0.000004   let wordcount = s:get_wordcount(0)
    1              0.000001   if wordcount != s:wordcount_cache || a:force_update
                                let s:wordcount_cache = wordcount
                                let b:airline_wordcount =  s:format_wordcount(wordcount)
                              endif

FUNCTION  ale#util#InSandbox()
Called 86 times
Total time:   0.001353
 Self time:   0.001230

count  total (s)   self (s)
   86              0.000117     try
   86   0.000623   0.000500         let &l:equalprg=&l:equalprg
   86              0.000172     catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
   86              0.000108     return 0

FUNCTION  airline#parts#crypt()
Called 2178 times
Total time:   0.007599
 Self time:   0.007599

count  total (s)   self (s)
 2178              0.006996   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#branch#head()
Called 2196 times
Total time:   0.718852
 Self time:   0.032416

count  total (s)   self (s)
 2196              0.004444   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
                              endif
                            
 2196   0.531242   0.006205   call s:update_branch()
 2196   0.167266   0.006529   call s:update_untracked()
                            
 2196              0.005670   if exists('b:airline_head') && !empty(b:airline_head)
 2187              0.001740     return b:airline_head
                              endif
                            
    9              0.000010   let b:airline_head = ''
    9              0.000021   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    9              0.000007   let heads = []
   27              0.000020   for vcs in vcs_priority
   18              0.000026     if !empty(b:buffer_vcs_config[vcs].branch)
    9              0.000019       let heads += [vcs]
    9              0.000004     endif
   18              0.000007   endfor
                            
   18              0.000013   for vcs in heads
    9              0.000009     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
    9              0.000009     if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
    9   0.000654   0.000072     let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
    9              0.000015     let b:airline_head .= b:buffer_vcs_config[vcs].untracked
    9              0.000005   endfor
                            
    9              0.000010   if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
    9              0.000008   if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
                              endif
                            
    9              0.000016   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
                              endif
                            
    9              0.000023   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
    9   0.000109   0.000029   let b:airline_head = airline#util#shorten(b:airline_head, 120, minwidth)
    9              0.000009   return b:airline_head

FUNCTION  airline#extensions#load_theme()
Called 9 times
Total time:   0.000118
 Self time:   0.000059

count  total (s)   self (s)
    9   0.000111   0.000052   call airline#util#exec_funcrefs(s:ext._theme_funcrefs, g:airline#themes#{g:airline_theme}#palette)

FUNCTION  221()
Called 4 times
Total time:   0.002488
 Self time:   0.002488

count  total (s)   self (s)
    4              0.000044     if exists("t:NERDTreeBufName")
    4              0.002430         return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                return -1

FUNCTION  222()
Called 4 times
Total time:   0.002555
 Self time:   0.000067

count  total (s)   self (s)
    4   0.002551   0.000063     return s:NERDTree.GetWinNum() != -1

FUNCTION  RelativeNumber()
Called 5 times
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
    5              0.000096       set number
    5              0.000034       set relativenumber

FUNCTION  airline#parts#mode()
Called 2178 times
Total time:   0.032153
 Self time:   0.010701

count  total (s)   self (s)
 2178   0.031491   0.010039   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  airline#extensions#quickfix#apply()
Called 18 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
   18              0.000026   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  442()
Called 864 times
Total time:   1.904118
 Self time:   0.025742

count  total (s)   self (s)
  864   0.012434   0.002149   call self.clear()
                            
  864   1.170590   0.003828   if vimtex#util#in_comment() | return | endif
                            
  861   0.484838   0.004171   let l:current = vimtex#delim#get_current('all', 'both')
  861              0.001830   if empty(l:current) | return | endif
                            
  328   0.222011   0.001349   let l:corresponding = vimtex#delim#get_matching(l:current)
  328              0.000702   if empty(l:corresponding) | return | endif
  328              0.000589   if empty(l:corresponding.match) | return | endif
                            
  328              0.000901   let [l:open, l:close] = l:current.is_open ? [l:current, l:corresponding] : [l:corresponding, l:current]
                            
  328              0.000487   if exists('*matchaddpos')
  328              0.004327     let w:vimtex_match_id1 = matchaddpos('MatchParen', [[l:open.lnum, l:open.cnum, strlen(l:open.match)]])
  328              0.002323     let w:vimtex_match_id2 = matchaddpos('MatchParen', [[l:close.lnum, l:close.cnum, strlen(l:close.match)]])
  328              0.000144   else
                                let w:vimtex_match_id1 = matchadd('MatchParen', '\%' . l:open.lnum . 'l\%' . l:open.cnum . 'c' . l:open.re.this)
                                let w:vimtex_match_id2 = matchadd('MatchParen', '\%' . l:close.lnum . 'l\%' . l:close.cnum . 'c' . l:close.re.this)
                              endif

FUNCTION  airline#extensions#wordcount#apply()
Called 18 times
Total time:   0.000553
 Self time:   0.000340

count  total (s)   self (s)
   18              0.000048   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes', s:filetypes)
                            
                              " Check if filetype needs testing
   18              0.000029   if did_filetype() || filetypes isnot s:filetypes
                                let s:filetypes = filetypes
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([])) ? index(filetypes, &filetype) > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
                              endif
                            
   18              0.000033   if exists('b:airline_wordcount')
   18   0.000272   0.000059     call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
   18              0.000004   endif

FUNCTION  <SNR>128_get_cmd_overlay()
Called 158 times
Total time:   0.001814
 Self time:   0.001814

count  total (s)   self (s)
  158              0.001027   let l:match = matchstr(getline(a:lnum), '^\s*[^>]*>', a:cnum)
                            
  158              0.000683   return empty(l:match) ? {} : {    'open' : {'lnum' : a:lnum, 'cnum' : a:cnum + 1},    'close' : {'lnum' : a:lnum, 'cnum' : a:cnum + strlen(l:match)},    'text' : l:match   }

FUNCTION  airline#highlighter#add_separator()
Called 496 times
Total time:   0.180607
 Self time:   0.004365

count  total (s)   self (s)
  496              0.001780   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
  496   0.178703   0.002461   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  <SNR>84_ale_refresh()
Called 4 times
Total time:   0.278066
 Self time:   0.000123

count  total (s)   self (s)
    4              0.000034   if get(g:, 'airline_skip_empty_sections', 0)
    4   0.278025   0.000082     exe ':AirlineRefresh'
    4              0.000003   endif

FUNCTION  ale#util#BinarySearch()
Called 86 times
Total time:   0.006212
 Self time:   0.006212

count  total (s)   self (s)
   86              0.000144     let l:min = 0
   86              0.000296     let l:max = len(a:loclist) - 1
                            
  172              0.000223     while 1
  172              0.000305         if l:max < l:min
   86              0.000110             return -1
                                    endif
                            
   86              0.000278         let l:mid = (l:min + l:max) / 2
   86              0.000240         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
   86              0.000187         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
   12              0.000015             let l:min = l:mid + 1
   12              0.000011         elseif l:item.lnum > a:line
   74              0.000171             let l:max = l:mid - 1
   74              0.000075         else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
   86              0.000102     endwhile

FUNCTION  airline#extensions#wordcount#get()
Called 2178 times
Total time:   0.019902
 Self time:   0.019827

count  total (s)   self (s)
 2178              0.002384   if s:visual_active
                                return s:format_wordcount(s:get_wordcount(1))
                              else
 2178              0.002926     if b:airline_changedtick != b:changedtick
    1   0.000083   0.000008       call s:update_wordcount(0)
    1              0.000001       let b:airline_changedtick = b:changedtick
    1              0.000000     endif
 2178              0.002245     return b:airline_wordcount
                              endif

FUNCTION  <SNR>97_PollFileParseResponse()
Called 1 time
Total time:   0.000152
 Self time:   0.000063

count  total (s)   self (s)
    1   0.000077   0.000004   if !s:Pyeval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
                              endif
                            
    1              0.000047   exec s:python_command "ycm_state.HandleFileParseRequest()"
    1   0.000020   0.000004   if s:Pyeval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
                              endif

FUNCTION  269()
Called 46 times
Total time:   0.000174
 Self time:   0.000174

count  total (s)   self (s)
   46              0.000160   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  ale#engine#GetLoclist()
Called 2186 times
Total time:   0.009961
 Self time:   0.009961

count  total (s)   self (s)
 2186              0.003633     if !has_key(g:ale_buffer_info, a:buffer)
                                    return []
                                endif
                            
 2186              0.003039     return g:ale_buffer_info[a:buffer].loclist

FUNCTION  vimtex#delim#get_next()
Called 474 times
Total time:   0.152318
 Self time:   0.003153

count  total (s)   self (s)
  474   0.152200   0.003035   return s:get_delim(extend({ 'direction' : 'next', 'type' : a:type, 'side' : a:side,}, get(a:, '1', {})))

FUNCTION  airline#util#has_lawrencium()
Called 2196 times
Total time:   0.005067
 Self time:   0.005067

count  total (s)   self (s)
 2196              0.004602   return exists('*lawrencium#statusline')

FUNCTION  airline#highlighter#get_highlight()
Called 6401 times
Total time:   0.540298
 Self time:   0.229090

count  total (s)   self (s)
 6401              0.016929   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                return s:hl_groups[a:group]
                              else
 6401   0.166510   0.022389     let fg = s:get_syn(a:group, 'fg')
 6401   0.149541   0.020041     let bg = s:get_syn(a:group, 'bg')
 6401              0.053997     let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
 6401              0.031090     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
 6401              0.006522     let opts = a:000
 6401              0.004392     if bold
  941              0.000986       let opts = ['bold']
  941              0.000443     endif
 6401   0.068127   0.030540     let res = reverse ? s:get_array(bg, fg, opts) : s:get_array(fg, bg, opts)
 6401              0.003240   endif
 6401              0.011937   let s:hl_groups[a:group] = res
 6401              0.004360   return res

FUNCTION  airline#util#shorten()
Called 2187 times
Total time:   0.021532
 Self time:   0.021532

count  total (s)   self (s)
 2187              0.006450   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
                              else
 2187              0.001784     return a:text
                              endif

FUNCTION  276()
Called 46 times
Total time:   0.284786
 Self time:   0.024247

count  total (s)   self (s)
   46              0.000044   let side = 1
   46              0.000038   let line = ''
   46              0.000043   let i = 0
   46              0.000083   let length = len(self._sections)
   46              0.000045   let split = 0
   46              0.000056   let is_empty = 0
   46              0.000045   let prev_group = ''
                            
  404              0.000452   while i < length
  358              0.000668     let section = self._sections[i]
  358              0.000512     let group = section[0]
  358              0.000484     let contents = section[1]
  358              0.000374     let pgroup = prev_group
  358   0.004844   0.001744     let prev_group = airline#builder#get_prev_group(self._sections, i)
  358              0.000679     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
   28              0.000058       let group = 'airline_c'. self._context.bufnr
   28              0.000075     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
   56              0.000111       let prev_group = 'airline_c'. self._context.bufnr
   56              0.000035     endif
  358              0.000247     if is_empty
                                  let prev_group = pgroup
                                endif
  358   0.019648   0.001303     let is_empty = s:section_is_empty(self, contents)
                            
  358              0.000252     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
   18              0.000018       let pgroup = group
   18              0.000006     endif
                            
  358              0.000305     if group == ''
                                  let line .= contents
                                elseif group == '|'
   46              0.000033       let side = 0
   46              0.000070       let line .= contents
   46              0.000032       let split = 1
   46              0.000025     else
  312              0.000269       if prev_group == ''
   46              0.000107         let line .= '%#'.group.'#'
   46              0.000032       elseif split
   46              0.000031         if !is_empty
   46   0.035422   0.000226           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
   46              0.000032         endif
   46              0.000038         let split = 0
   46              0.000030       else
  220              0.000159         if !is_empty
  202   0.195008   0.000940           let line .= s:get_seperator(self, prev_group, group, side)
  202              0.000126         endif
  220              0.000107       endif
  312   0.011636   0.001806       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
  312              0.000159     endif
                            
  358              0.000606     let i = i + 1
  358              0.000268   endwhile
                            
   46              0.000054   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
   28              0.001474     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
   28              0.000024   endif
   46              0.000057   return line

FUNCTION  <SNR>77_check_defined_section()
Called 18 times
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
   18              0.000043   if !exists('w:airline_section_{a:name}')
   18              0.000048     let w:airline_section_{a:name} = g:airline_section_{a:name}
   18              0.000010   endif

FUNCTION  <SNR>185_StopCursorTimer()
Called 868 times
Total time:   0.005546
 Self time:   0.005546

count  total (s)   self (s)
  868              0.001078     if s:cursor_timer != -1
  863              0.002161         call timer_stop(s:cursor_timer)
  863              0.001050         let s:cursor_timer = -1
  863              0.000401     endif

FUNCTION  airline#extensions#branch#get_head()
Called 2196 times
Total time:   0.745663
 Self time:   0.026811

count  total (s)   self (s)
 2196   0.724639   0.005787   let head = airline#extensions#branch#head()
 2196              0.005277   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
 2196              0.004922   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
 2196              0.009658   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  airline#extensions#keymap#status()
Called 2178 times
Total time:   0.015349
 Self time:   0.015349

count  total (s)   self (s)
 2178              0.007902   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
 2178              0.006543     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  airline#themes#generate_color_map()
Called 45 times
Total time:   0.004113
 Self time:   0.004113

count  total (s)   self (s)
   45              0.001498   let palette = { 'airline_a': [ a:sect1[0] , a:sect1[1] , a:sect1[2] , a:sect1[3] , get(a:sect1 , 4 , '') ] , 'airline_b': [ a:sect2[0] , a:sect2[1] , a:sect2[2] , a:sect2[3] , get(a:sect2 , 4 , '') ] , 'airline_c': [ a:sect3[0] , a:sect3[1] , a:sect3[2] , a:sect3[3] , get(a:sect3 , 4 , '') ] , }
                            
   45              0.000125   if a:0 > 0
                                call extend(palette, { 'airline_x': [ a:1[0] , a:1[1] , a:1[2] , a:1[3] , get(a:1 , 4 , '' ) ] , 'airline_y': [ a:2[0] , a:2[1] , a:2[2] , a:2[3] , get(a:2 , 4 , '' ) ] , 'airline_z': [ a:3[0] , a:3[1] , a:3[2] , a:3[3] , get(a:3 , 4 , '' ) ] , })
                              else
   45              0.001353     call extend(palette, { 'airline_x': [ a:sect3[0] , a:sect3[1] , a:sect3[2] , a:sect3[3] , '' ] , 'airline_y': [ a:sect2[0] , a:sect2[1] , a:sect2[2] , a:sect2[3] , '' ] , 'airline_z': [ a:sect1[0] , a:sect1[1] , a:sect1[2] , a:sect1[3] , '' ] , })
   45              0.000069   endif
                            
   45              0.000125   return palette

FUNCTION  <SNR>96_GetCounts()
Called 2204 times
Total time:   0.026448
 Self time:   0.026448

count  total (s)   self (s)
 2204              0.007706     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return s:CreateCountDict()
                                endif
                            
                                " Cache is cold, so manually ask for an update.
 2204              0.004590     if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(a:buffer, g:ale_buffer_info[a:buffer].loclist)
                                endif
                            
 2204              0.003072     return g:ale_buffer_info[a:buffer].count

FUNCTION  ale#balloon#MessageForPos()
Called 1 time
Total time:   0.001706
 Self time:   0.000185

count  total (s)   self (s)
                                " Don't show balloons if they are disabled, or linting is disabled.
    1   0.000084   0.000028     if !ale#Var(a:bufnr, 'set_balloons')|| !g:ale_enabled|| !getbufvar(a:bufnr, 'ale_enabled', 1)
                                    return ''
                                endif
                            
    1              0.000018     let l:loclist = get(g:ale_buffer_info, a:bufnr, {'loclist': []}).loclist
    1   0.000257   0.000022     let l:index = ale#util#BinarySearch(l:loclist, a:bufnr, a:lnum, a:col)
                            
                                " Show the diagnostics message if found, 'Hover' output otherwise
    1              0.000004     if l:index >= 0
                                    return l:loclist[l:index].text
                                elseif exists('*balloon_show') || getbufvar(   a:bufnr,   'ale_set_balloons_legacy_echo',   get(g:, 'ale_set_balloons_legacy_echo', 0))
                                    " Request LSP/tsserver hover information, but only if this version of
                                    " Vim supports the balloon_show function, or if we turned a legacy
                                    " setting on.
    1   0.001293   0.000063         call ale#hover#Show(a:bufnr, a:lnum, a:col, {'called_from_balloonexpr': 1})
    1              0.000002     endif
                            
    1              0.000003     return ''

FUNCTION  <SNR>82_update_hg_branch()
Called 2196 times
Total time:   0.080191
 Self time:   0.075124

count  total (s)   self (s)
 2196   0.011470   0.006403   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
 2196              0.003577     let s:vcs_config['mercurial'].branch = ''
 2196              0.000976   endif

FUNCTION  vimtex#cmd#get_at()
Called 158 times
Total time:   0.260308
 Self time:   0.002120

count  total (s)   self (s)
  158   0.001008   0.000429   let l:pos_saved = vimtex#pos#get_cursor()
  158   0.003865   0.000504   call call('vimtex#pos#set_cursor', a:000)
  158   0.252393   0.000475   let l:cmd = vimtex#cmd#get_current()
  158   0.002809   0.000479   call vimtex#pos#set_cursor(l:pos_saved)
  158              0.000125   return l:cmd

FUNCTION  airline#highlighter#reset_hlcache()
Called 9 times
Total time:   0.000868
 Self time:   0.000868

count  total (s)   self (s)
    9              0.000857   let s:hl_groups = {}

FUNCTION  airline#util#prepend()
Called 4392 times
Total time:   0.018023
 Self time:   0.018023

count  total (s)   self (s)
 4392              0.005549   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 4392              0.007567   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>142_parse_args()
Called 4269 times
Total time:   0.058057
 Self time:   0.056157

count  total (s)   self (s)
                              "
                              " The arguments should be in one of the following forms (when unpacked):
                              "
                              "   [lnum, cnum]
                              "   [bufnum, lnum, cnum, ...]
                              "   {'lnum' : lnum, 'cnum' : cnum}
                              "
                            
 4269              0.006245   if len(a:args) > 1
  158              0.000359     return s:parse_args([a:args])
                              elseif len(a:args) == 1
 4111              0.009214     if type(a:args[0]) == type({})
 1151              0.003199       return [get(a:args[0], 'lnum'), get(a:args[0], 'cnum')]
                                else
 2960              0.003406       if len(a:args[0]) == 2
  158              0.000157         return a:args[0]
                                  else
 2802              0.004547         return a:args[0][1:]
                                  endif
                                endif
                              else
                                return a:args
                              endif

FUNCTION  vimtex#cmd#get_current()
Called 158 times
Total time:   0.251918
 Self time:   0.004859

count  total (s)   self (s)
  158   0.000921   0.000376   let l:save_pos = vimtex#pos#get_cursor()
  158   0.003641   0.000539   let l:pos_val_cursor = vimtex#pos#val(l:save_pos)
                            
  158              0.000145   let l:depth = 3
  158              0.000183   while l:depth > 0
  158              0.000192     let l:depth -= 1
  158   0.239575   0.001352     let l:cmd = s:get_cmd('prev')
  158              0.000370     if empty(l:cmd) | break | endif
                            
  158   0.003244   0.000567     let l:pos_val = vimtex#pos#val(l:cmd.pos_end)
  158              0.000202     if l:pos_val >= l:pos_val_cursor
  158   0.002973   0.000461       call vimtex#pos#set_cursor(l:save_pos)
  158              0.000180       return l:cmd
                                else
                                  call vimtex#pos#set_cursor(vimtex#pos#prev(l:cmd.pos_start))
                                endif
                              endwhile
                            
                              call vimtex#pos#set_cursor(l:save_pos)
                            
                              return {}

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 868 times
Total time:   0.042418
 Self time:   0.028596

count  total (s)   self (s)
  868              0.002586     let l:buffer = bufnr('')
                            
  868              0.001356     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
  868              0.001631     if mode(1) isnot# 'n'
                                    return
                                endif
                            
  868   0.009070   0.003524     call s:StopCursorTimer()
                            
  868              0.003614     let l:pos = getcurpos()[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
  868              0.001275     if l:pos != s:last_pos
  864   0.011377   0.003101         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
  864              0.001190         let s:last_pos = l:pos
  864              0.003116         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
  864              0.000419     endif

FUNCTION  <SNR>94_get_seperator()
Called 202 times
Total time:   0.194068
 Self time:   0.001719

count  total (s)   self (s)
  202   0.040881   0.000730   if airline#builder#should_change_group(a:prev_group, a:group)
  202   0.153117   0.000919     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>128_text_between()
Called 680 times
Total time:   0.011183
 Self time:   0.011183

count  total (s)   self (s)
  680              0.001906   let [l1, c1] = [a:p1.lnum, a:p1.cnum - (a:0 > 0)]
  680              0.001262   let [l2, c2] = [a:p2.lnum, a:p2.cnum - (a:0 <= 0)]
                            
  680              0.001345   let lines = getline(l1, l2)
  680              0.000785   if !empty(lines)
  680              0.001679     let lines[0] = strpart(lines[0], c1)
  680              0.002061     let lines[-1] = strpart(lines[-1], 0, l1 == l2 ? c2 - c1 : c2)
  680              0.000328   endif
  680              0.001198   return join(lines, "\n")

FUNCTION  airline#extensions#ale#get_warning()
Called 2186 times
Total time:   0.170169
 Self time:   0.007288

count  total (s)   self (s)
 2186   0.169754   0.006873   return airline#extensions#ale#get('warning')

FUNCTION  airline#builder#new()
Called 46 times
Total time:   0.000986
 Self time:   0.000986

count  total (s)   self (s)
   46              0.000264   let builder = copy(s:prototype)
   46              0.000101   let builder._context = a:context
   46              0.000063   let builder._sections = []
                            
   46              0.000428   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   46              0.000059   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  864   1.904118   0.025742  442()
  888   1.206097             vimtex#util#in_syntax()
  864   1.166762   0.005111  vimtex#util#in_comment()
 2196   0.745663   0.026811  airline#extensions#branch#get_head()
 2196   0.718852   0.032416  airline#extensions#branch#head()
   33   0.657337   0.070108  airline#highlighter#highlight()
 1335   0.622232   0.358328  <SNR>131_get_delim()
    9   0.581527   0.000959  <SNR>56_airline_refresh()
  865   0.565936             <SNR>65_Highlight_Matching_Pair()
 6401   0.540298   0.229090  airline#highlighter#get_highlight()
 2196   0.525037   0.067625  <SNR>82_update_branch()
 3437   0.512777   0.151059  airline#highlighter#exec()
    9   0.482145   0.001236  airline#load_theme()
  861   0.480667   0.007600  vimtex#delim#get_current()
 2200   0.452758   0.149339  airline#check_mode()
 1280   0.429678   0.031760  <SNR>91_exec_separator()
 2196   0.377221   0.031798  <SNR>82_update_git_branch()
    9   0.362182   0.000818  airline#highlighter#load_theme()
 2196   0.339457   0.018935  FugitiveHead()
   46   0.318622   0.001525  <SNR>79_invoke_funcrefs()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  888              1.206097  vimtex#util#in_syntax()
  865              0.565936  <SNR>65_Highlight_Matching_Pair()
 1335   0.622232   0.358328  <SNR>131_get_delim()
 2196              0.313114  fugitive#Head()
12802              0.273621  <SNR>91_get_syn()
 6401   0.540298   0.229090  airline#highlighter#get_highlight()
 3437   0.512777   0.151059  airline#highlighter#exec()
 2200   0.452758   0.149339  airline#check_mode()
 2196   0.160737   0.142790  <SNR>82_update_untracked()
 3759              0.123581  vimtex#matchparen#popup_check()
15246              0.083372  airline#util#append()
 2178   0.089820   0.076789  airline#extensions#vimtex#get_scope()
 2196   0.080191   0.075124  <SNR>82_update_hg_branch()
 2178              0.073130  airline#util#ignore_buf()
   33   0.657337   0.070108  airline#highlighter#highlight()
 2196   0.525037   0.067625  <SNR>82_update_branch()
 2204   0.163641   0.063369  airline#extensions#ale#get()
 4269   0.058057   0.056157  <SNR>142_parse_args()
  864   0.083932   0.055754  <SNR>97_OnCursorMovedNormalMode()
 2204   0.059129   0.049168  <SNR>84_airline_ale_get_line_number()

