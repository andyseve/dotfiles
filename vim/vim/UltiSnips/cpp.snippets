# Common functions {{{
snippet forg  "General for loop"
for(${1:int} ${2:i} = ${4:0} ; $2 < ${4:n}; ${5:++$2}){
	$0
}
endsnippet
snippet for "Basic for loop"
for(int ${1:i} = 0; $1 < ${2:n}; ++$2){
	$0
}
endsnippet
snippet fori "Incremental for loop"
for(int ${1:i} = ${2:a}; $1 < ${3:b}; ++$2){
	$0
}
endsnippet
# }}}
# Number Theory {{{
snippet miller_rabin "Miller Rabin Primality Test" b
bool miller_rabin(${1:int} p){
	$1 s = 0; $1 r = p-1;
	while(! (r % 2)) s++, r /= 2;
	int l[9] = {2,3,5,7,11,13,17,19,23};
	for(int i = 0 ; i < 9; ++i){
		$1 a = l[i];
		if(a == p) continue;
		$1 y = pow(a, r, p);
		if(y != 1 && y != p-1){
			for(int j = 0 ; j < s; ++j){
				y = mul(y,y,p);
				if( y == p-1) break;
			if( y == 1) return false;
			}
			if(y != p-1) return false;
		}
	}
	return true;
}
endsnippet
snippet mod "Global mod functions" b
${1:int} mod = ${2:1000000007};
inline $1 sum($1 a, $1 b) { return ($1) ((a + b) % mod);}
inline $1 mul($1 a, $1 b) { return ($1) ((1ll * a * b) % mod); }
$1 pow($1 x, $1 a){
	if(a == 0) return 1;
	$1 ret = pow(x, a/2);
	ret = mul(ret, ret);
	if(a % 2) ret = mul(x, ret);
	return ret;
}
$1 inv(int x){
	return pow(x, mod - 1);
}
endsnippet
snippet mod "Local mod functions" b
inline ${1:int} sum($1 a, $1 b, $1 mod) { return ($1) ((a + b) % mod);}
inline $1 mul($1 a, $1 b, $1 mod) { return ($1) ((1ll * a * b) % mod); }
$1 pow($1 x, $1 a, $1 mod){
	if(a == 0) return 1;
	$1 ret = pow(x, a/2, mod);
	ret = mul(ret, ret, mod);
	if(a % 2) ret = mul(x, ret, mod);
	return ret;
}
$1 inv($1 x, $1 mod){
	return pow(x, mod - 1, mod);
}
endsnippet
# }}}
# Geometry {{{
snippet 3dvec "3D vectors" b
// 3d vector (can degenerate to 2d when z=0)
#define T ${1:long double}
struct vec {
	T x,y,z;	//coordinates/data
	vec(T xx, T yy, T zz=0.){ x=xx;y=yy;z=zz; }
	vec() { x=y=z=0;}

	// vector ops
	vec& operator=(const vec& b) { x=b.x; y=b.y; z=b.z; return *this; }
	vec operator+(const vec& b) const { return vec(x+b.x, y+b.y, z+b.z); }
	vec operator-(const vec& b) const { return vec(x-b.x, y-b.y, z-b.z); }
	T operator*(const vec& b) const { return x*b.x + y*b.y + z*b.z; }
	vec operator^(const vec& b) const { return vec(y*b.z - z*b.y,
												   z*b.x - x*b.z,
												   x*b.y - y*b.x); }
	// scalar mult
	vec operator*(T k) const { return vec(x*k,y*k,z*k); }
	vec operator/(T k) const { return vec(x/k,y/k,z/k); }
	vec operator-() const { return vec(-x,-y,-z); }  // negation
	
	T sqlen() const { return (*this) * (*this); }

	bool operator<(const vec& other) const {
		if (x < other.x) return true;
		if (x > other.x) return false;
		if (y < other.y) return true;
		if (y > other.y) return false;
		if (z < other.z) return true;
		if (z > other.z) return false;
		return false;
	}
};
vec operator*(T k, vec v) { return v*k; }
ostream& operator<<(ostream& out, const vec& v) {
	return out << "(" << v.x << "," << v.y << "," << v.z <<")";
}
#undef T
endsnippet
# }}}
# vim ts=4 sts=4 foldmethod=marker foldlevel=0 noexpandtab
