# # Templates
snippet code "Main template" b
#include<bits/stdc++.h>
using namespace std;

int main(){
	freopen("${1:in}", "r", stdin); freopen("${2:out}", "w", stdout);
	ios_base::sync_with_stdio(false);
	$0
}
endsnippet
snippet temp "Basic Template" b
#include<bits/stdc++.h>
using namespace std;

int main(){
	$0
}
endsnippet
snippet freopen "freopen line" b
freopen("${1:in}", "r", stdin); freopen("${2:out}", "w", stdout);
$0
endsnippet
snippet cin "optimized cin" b
ios_base::sync_with_stdio(false);
$0
endsnippet
snippet infi "infinity" b
const int ${1:inf} = 1 << 30;
$0
endsnippet
snippet infl "infinity" b
const long long ${1:inf} = 1ll << 62;
$0
endsnippet

# # Common functions
snippet forg  "General for loop"
for(${1:int} ${2:i} = ${4:0} ; $2 < ${4:n}; ${5:++$2}){
	$0
}
endsnippet
snippet for "Basic for loop" 
for(int ${1:i} = 0; $1 < ${2:n}; ++$1){
	$0
}
endsnippet
snippet fori "Incremental for loop"
for(int ${1:i} = ${2:a}; $1 < ${3:b}; ++$1){
	$0
}
endsnippet
snippet ford "Decreasing for loop"
for(int ${1:i} = ${2:n}; $1 > ${3:-1}; --$1){
	$0
}
endsnippet
snippet bsl "Binary Search" b
// returns smallest index with >= s;
int ${1:bs}(int s, int l, int r){
	if(l == r) return l;
	int mid = (l + r)/2;
	if(${2:array}[mid] < s) return $1(s, mid+1, r);
	else return $1(s, l, mid);
}
endsnippet
snippet bsg "Binary Search" b
// returns largest index with >= s;
int ${1:bs}(int s, int l, int r){
	if(l == r) return l;
	int mid = (l + r)/2;
	if(${2:array}[mid] > s) return $1(s, l, mid-1);
	else return $1(s, mid, r);
}
endsnippet

# # Number Theory
snippet miller_rabin "Miller Rabin Primality Test" b
bool miller_rabin(${1:int} p){
	$1 s = 0; $1 r = p-1;
	while(! (r % 2)) s++, r /= 2;
	int l[9] = {2,3,5,7,11,13,17,19,23};
	for(int i = 0 ; i < 9; ++i){
		$1 a = l[i];
		if(a == p) continue;
		$1 y = pow(a, r, p);
		if(y != 1 && y != p-1){
			for(int j = 0 ; j < s; ++j){
				y = mul(y,y,p);
				if( y == p-1) break;
			if( y == 1) return false;
			}
			if(y != p-1) return false;
		}
	}
	return true;
}
endsnippet
snippet mod "mod value" b
const int ${1:mod} = ${2:1000000007};
$0
endsnippet
snippet mod2 "mod value 2" b
const int ${1:mod} = 998244353;
$0
endsnippet
snippet modf "mod functions" b
inline ${1:int} sum($1 a, $1 b, $1 mod) { return ($1) ((a + b) % mod); }
inline $1 mul($1 a, $1 b, $1 mod) { return ($1) ((1ll * a * b) % mod); }
$1 pow($1 x, $1 a, $1 mod){
	if(a == 0) return 1;
	$1 ret = pow(x, a/2, mod);
	ret = mul(ret, ret, mod);
	if(a % 2) ret = mul(x, ret, mod);
	return ret;
}
$1 inv($1 x, $1 mod){
	return pow(x, mod - 2, mod);
}
endsnippet
snippet gcd "Euclid's Algorithm" b
${1:long long} gcd($1 a, $1 b){
	if(b == 0) return a;
	else return gcd(b, a % b);
}
$0
endsnippet
snippet frac "Fraction Functions" b
inline pair<${1:int},$1> sum(pair<$1,$1> a, pair<$1,$1>b){
	return make_pair(
			sum(mul(a.first, b.second), mul(a.second, b.first)),
			mul(a.second, b.second)
			);
}
inline pair<$1,$1> mul(pair<$1,$1> a, pair<$1,$1> b){
	return make_pair(
			mul(a.first, b.first),
			mul(a.second, b.second)
			);
}
inline pair<$1,$1> sub(pair<$1,$1> a, pair<$1, $1>b){
	return make_pair(
			sum(mul(a.first, b.second), - mul(a.second, b.first)),
			mul(a.second, b.second)
			);
}
endsnippet

# # Geometry
snippet 3dvec "3D vectors" b
// 3d vector (can degenerate to 2d when z=0)
#define T ${1:long double}
struct vec {
	T x,y,z;	//coordinates/data
	vec(T xx, T yy, T zz=0.){ x=xx;y=yy;z=zz; }
	vec() { x=y=z=0;}

	// vector ops
	vec& operator=(const vec& b) { x=b.x; y=b.y; z=b.z; return *this; }
	vec operator+(const vec& b) const { return vec(x+b.x, y+b.y, z+b.z); }
	vec operator-(const vec& b) const { return vec(x-b.x, y-b.y, z-b.z); }
	T operator*(const vec& b) const { return x*b.x + y*b.y + z*b.z; }
	vec operator^(const vec& b) const { return vec(y*b.z - z*b.y,
												   z*b.x - x*b.z,
												   x*b.y - y*b.x); }
	// scalar mult
	vec operator*(T k) const { return vec(x*k,y*k,z*k); }
	vec operator/(T k) const { return vec(x/k,y/k,z/k); }
	vec operator-() const { return vec(-x,-y,-z); }  // negation
	
	T sqlen() const { return (*this) * (*this); }

	bool operator<(const vec& other) const {
		if (x < other.x) return true;
		if (x > other.x) return false;
		if (y < other.y) return true;
		if (y > other.y) return false;
		if (z < other.z) return true;
		if (z > other.z) return false;
		return false;
	}
};
vec operator*(T k, vec v) { return v*k; }
ostream& operator<<(ostream& out, const vec& v) {
	return out << "(" << v.x << "," << v.y << "," << v.z <<")";
}
#undef T
endsnippet
# # Data Structures
snippet prefix_tree "Prefix sum segment tree" b
// Prefix tree
// combine can be min, max (non commutative?)
${1:int} ${2:seg}[2 * ${3:N}];
$1 ${6:query}(int l, int r){
	l += $3, r+= $3; //can be replace by actual upperbound
	$1 ans = ${4:0}; //identity element under $5
	while(l < r){
		if( l & 1 ) ans = ${5:combine}($2[l++], ans);
		if( r & 1 ) ans = $5($2[--r], ans);
		l >>= 1 , r >>= 1;
	}
	return ans;
}

void ${7:update}(int i, $1 val){
	i += $3; // can be replaced by actual upperbound
	$1[i] = val; i >>= 1;
	while(i > 0){
		$2[i] = $5($2[2 * i], $2[2 * i + 1]);
		i >>= 1;
	}
}
void ${8:fill}() {for(int i=0; i < 2 * N; ++i) $2[i] = $4;}

endsnippet
# # Debug {{{
snippet debug "basic debug" b
cout << "debug-------------: " << $1 << endl;
$0
endsnippet
# vim:ts=4:sts=4:foldmethod=marker:foldlevel=0:noexpandtab
